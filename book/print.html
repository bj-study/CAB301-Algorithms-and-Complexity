<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>CAB301 Algorithms and Complexity</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="preface.html">Preface</a></li><li class="chapter-item expanded "><a href=".week_1/preface.html"><strong aria-hidden="true">1.</strong> Week 1</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">1.1.</strong> Overview</div></li><li class="chapter-item expanded "><a href="week_1/1-2.html"><strong aria-hidden="true">1.2.</strong> Learning activities</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">1.2.1.</strong> Download and examine</div></li><li class="chapter-item expanded "><a href="week_1/1-2-2.html"><strong aria-hidden="true">1.2.2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="week_1/1-2-3.html"><strong aria-hidden="true">1.2.3.</strong> What is an algorithm</a></li><li class="chapter-item expanded "><a href="week_1/1-2-4.html"><strong aria-hidden="true">1.2.4.</strong> Pseudocode notations</a></li><li class="chapter-item expanded "><a href="week_1/1-2-5.html"><strong aria-hidden="true">1.2.5.</strong> Algorithm efficiency and algorithm analysis</a></li><li class="chapter-item expanded "><a href="week_1/1-2-6.html"><strong aria-hidden="true">1.2.6.</strong> Algorithm analysis - An example</a></li><li class="chapter-item expanded "><a href="week_1/1-2-7.html"><strong aria-hidden="true">1.2.7.</strong> Why do we need to worry about the efficiency of an algorithm?</a></li><li class="chapter-item expanded "><a href="week_1/1-2-8.html"><strong aria-hidden="true">1.2.8.</strong> The tower of Hanoi problem</a></li><li class="chapter-item expanded "><a href="week_1/1-2-9.html"><strong aria-hidden="true">1.2.9.</strong> The Tower of Hanoi - Code example</a></li><li class="chapter-item expanded "><a href="week_1/1-2-10.html"><strong aria-hidden="true">1.2.10.</strong> What are data structures</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.3.</strong> Workshop</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.4.</strong> After Workshop</div></li><li class="chapter-item expanded "><a href="week_1/module-references.html"><strong aria-hidden="true">1.5.</strong> References</a></li></ol></li><li class="chapter-item expanded "><a href=".week_2/preface.html"><strong aria-hidden="true">2.</strong> Week 2</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">2.1.</strong> Overview</div></li><li class="chapter-item expanded "><a href="week_2/2-2.html"><strong aria-hidden="true">2.2.</strong> Learning activities</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">2.2.1.</strong> Download and examine</div></li><li class="chapter-item expanded "><a href="week_2/2-2-2.html"><strong aria-hidden="true">2.2.2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="week_2/2-2-3.html"><strong aria-hidden="true">2.2.3.</strong> How to perform a theoretical analysis of algorithm efficiency</a></li><li class="chapter-item expanded "><a href="week_2/2-2-4.html"><strong aria-hidden="true">2.2.4.</strong> Big-O notation</a></li><li class="chapter-item expanded "><a href="week_2/2-2-5.html"><strong aria-hidden="true">2.2.5.</strong> Algorithm analysis - An example</a></li><li class="chapter-item expanded "><a href="week_2/2-2-6.html"><strong aria-hidden="true">2.2.6.</strong> Derive algorithm efficiency from its structure</a></li><li class="chapter-item expanded "><a href="week_2/2-2-7.html"><strong aria-hidden="true">2.2.7.</strong> Empirical analysis of an algorithms efficiency</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.3.</strong> Workshop</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.4.</strong> After Workshop</div></li><li class="chapter-item expanded "><a href="week_2/module-references.html"><strong aria-hidden="true">2.5.</strong> References</a></li></ol></li><li class="chapter-item expanded "><a href=".week_3/preface.html"><strong aria-hidden="true">3.</strong> Week 3</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">3.1.</strong> Overview</div></li><li class="chapter-item expanded "><a href="week_3/3-2.html"><strong aria-hidden="true">3.2.</strong> Learning activities</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">3.2.1.</strong> Download and examine</div></li><li class="chapter-item expanded "><a href="week_3/3-2-2.html"><strong aria-hidden="true">3.2.2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="week_3/3-2-3.html"><strong aria-hidden="true">3.2.3.</strong> Arrays</a></li><li class="chapter-item expanded "><a href="week_3/3-2-4.html"><strong aria-hidden="true">3.2.4.</strong> Linked Lists</a></li><li class="chapter-item expanded "><a href="week_3/3-2-5.html"><strong aria-hidden="true">3.2.5.</strong> Arrays vs Linked Lists</a></li><li class="chapter-item expanded "><a href="week_3/3-2-6.html"><strong aria-hidden="true">3.2.6.</strong> Stacks</a></li><li class="chapter-item expanded "><a href="week_3/3-2-7.html"><strong aria-hidden="true">3.2.7.</strong> Queues</a></li><li class="chapter-item expanded "><a href="week_3/3-2-8.html"><strong aria-hidden="true">3.2.8.</strong> Search Algorithms</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="week_3/3-2-8-1.html"><strong aria-hidden="true">3.2.8.1.</strong> Sequential Search</a></li><li class="chapter-item expanded "><a href="week_3/3-2-8-3.html"><strong aria-hidden="true">3.2.8.2.</strong> Binary Search</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.3.</strong> Workshop</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.4.</strong> After Workshop</div></li><li class="chapter-item expanded "><a href="week_3/module-references.html"><strong aria-hidden="true">3.5.</strong> References</a></li></ol></li><li class="chapter-item expanded "><a href=".week_4/preface.html"><strong aria-hidden="true">4.</strong> Week 4</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.</strong> Overview</div></li><li class="chapter-item expanded "><a href="week_4/4-2.html"><strong aria-hidden="true">4.2.</strong> Learning activities</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.2.1.</strong> Download and examine</div></li><li class="chapter-item expanded "><a href="week_4/4-2-2.html"><strong aria-hidden="true">4.2.2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="week_4/4-2-3.html"><strong aria-hidden="true">4.2.3.</strong> Stable sorting algorithms</a></li><li class="chapter-item expanded "><a href="week_4/4-2-4.html"><strong aria-hidden="true">4.2.4.</strong> Insertion Sort</a></li><li class="chapter-item expanded "><a href="week_4/4-2-5.html"><strong aria-hidden="true">4.2.5.</strong> Selection Sort</a></li><li class="chapter-item expanded "><a href="week_4/4-2-6.html"><strong aria-hidden="true">4.2.6.</strong> Bubble Sort</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.3.</strong> Workshop</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.4.</strong> After Workshop</div></li><li class="chapter-item expanded "><a href="week_4/module-references.html"><strong aria-hidden="true">4.5.</strong> References</a></li></ol></li><li class="chapter-item expanded "><a href=".week_5/preface.html"><strong aria-hidden="true">5.</strong> Week 5</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.</strong> Overview</div></li><li class="chapter-item expanded "><a href="week_5/5-2.html"><strong aria-hidden="true">5.2.</strong> Learning activities</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.2.1.</strong> Download and examine</div></li><li class="chapter-item expanded "><a href="week_5/5-2-2.html"><strong aria-hidden="true">5.2.2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="week_5/5-2-3.html"><strong aria-hidden="true">5.2.3.</strong> Binary Tree Implementation</a></li><li class="chapter-item expanded "><a href="week_5/5-2-4.html"><strong aria-hidden="true">5.2.4.</strong> Binary Tree Traversal</a></li><li class="chapter-item expanded "><a href="week_5/5-2-5.html"><strong aria-hidden="true">5.2.5.</strong> Binary Search Tree: Search</a></li><li class="chapter-item expanded "><a href="week_5/5-2-6.html"><strong aria-hidden="true">5.2.6.</strong> Binary Search Tree: Insert</a></li><li class="chapter-item expanded "><a href="week_5/5-2-7.html"><strong aria-hidden="true">5.2.7.</strong> Binary Search Tree: Delete</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.2.8.</strong> Demonstration: How to implement a BST ADT</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.</strong> Workshop</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.4.</strong> After Workshop</div></li><li class="chapter-item expanded "><a href="week_5/module-references.html"><strong aria-hidden="true">5.5.</strong> References</a></li></ol></li><li class="chapter-item expanded "><a href=".week_6/preface.html"><strong aria-hidden="true">6.</strong> Week 6</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> Overview</div></li><li class="chapter-item expanded "><a href="week_6/6-2.html"><strong aria-hidden="true">6.2.</strong> Learning activities</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.1.</strong> Download and examine</div></li><li class="chapter-item expanded "><a href="week_6/6-2-2.html"><strong aria-hidden="true">6.2.2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="week_6/6-2-3.html"><strong aria-hidden="true">6.2.3.</strong> Merge Sort</a></li><li class="chapter-item expanded "><a href="week_6/6-2-6.html"><strong aria-hidden="true">6.2.4.</strong> Quick Sort</a></li><li class="chapter-item expanded "><a href="week_6/6-2-9.html"><strong aria-hidden="true">6.2.5.</strong> Heap Sort & Complete Binary Trees</a></li><li class="chapter-item expanded "><a href="week_6/6-2-10.html"><strong aria-hidden="true">6.2.6.</strong> Heaps and Heap Bottom Up</a></li><li class="chapter-item expanded "><a href="week_6/6-2-11.html"><strong aria-hidden="true">6.2.7.</strong> Maximum Key Deletion</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.3.</strong> Workshop</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.4.</strong> After Workshop</div></li><li class="chapter-item expanded "><a href="week_6/module-references.html"><strong aria-hidden="true">6.5.</strong> References</a></li></ol></li><li class="chapter-item expanded "><a href=".week_7/preface.html"><strong aria-hidden="true">7.</strong> Week 7</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">7.1.</strong> Overview</div></li><li class="chapter-item expanded "><a href="week_7/7-2.html"><strong aria-hidden="true">7.2.</strong> Learning activities</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">7.2.1.</strong> Download and examine</div></li><li class="chapter-item expanded "><a href="week_7/7-2-2.html"><strong aria-hidden="true">7.2.2.</strong> Trees</a></li><li class="chapter-item expanded "><a href="week_7/7-2-3.html"><strong aria-hidden="true">7.2.3.</strong> Tree Implementation</a></li><li class="chapter-item expanded "><a href="week_7/7-2-4.html"><strong aria-hidden="true">7.2.4.</strong> Breadth First Traversal</a></li><li class="chapter-item expanded "><a href="week_7/7-2-5.html"><strong aria-hidden="true">7.2.5.</strong> Depth First Traversal</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.3.</strong> Workshop</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.4.</strong> After Workshop</div></li><li class="chapter-item expanded "><a href="week_7/module-references.html"><strong aria-hidden="true">7.5.</strong> References</a></li></ol></li><li class="chapter-item expanded "><a href=".week_8/preface.html"><strong aria-hidden="true">8.</strong> Week 8</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">8.1.</strong> Overview</div></li><li class="chapter-item expanded "><a href="week_8/8-2.html"><strong aria-hidden="true">8.2.</strong> Learning activities</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">8.2.1.</strong> Download and examine</div></li><li class="chapter-item expanded "><a href="week_8/8-2-2.html"><strong aria-hidden="true">8.2.2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="week_8/8-2-3.html"><strong aria-hidden="true">8.2.3.</strong> Graphs</a></li><li class="chapter-item expanded "><a href="week_8/8-2-4.html"><strong aria-hidden="true">8.2.4.</strong> Adjacency Matrix</a></li><li class="chapter-item expanded "><a href="week_8/8-2-5.html"><strong aria-hidden="true">8.2.5.</strong> Adjacency List</a></li><li class="chapter-item expanded "><a href="week_8/8-2-6.html"><strong aria-hidden="true">8.2.6.</strong> Graph Traversal</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="week_8/8-2-6-1.html"><strong aria-hidden="true">8.2.6.1.</strong> Depth-first Search</a></li><li class="chapter-item expanded "><a href="week_8/8-2-6-2.html"><strong aria-hidden="true">8.2.6.2.</strong> Breadth-first Search</a></li></ol></li><li class="chapter-item expanded "><a href="week_8/8-2-7.html"><strong aria-hidden="true">8.2.7.</strong> Topological Sort</a></li><li class="chapter-item expanded "><a href="week_8/8-2-8.html"><strong aria-hidden="true">8.2.8.</strong> Spanning Tree & Minimum Spanning Tree</a></li><li class="chapter-item expanded "><a href="week_8/8-2-9.html"><strong aria-hidden="true">8.2.9.</strong> Kruskal's Algorithm</a></li><li class="chapter-item expanded "><a href="week_8/8-2-10.html"><strong aria-hidden="true">8.2.10.</strong> Prims's Algorithm</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.3.</strong> Workshop</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.4.</strong> After Workshop</div></li><li class="chapter-item expanded "><a href="week_8/module-references.html"><strong aria-hidden="true">8.5.</strong> References</a></li></ol></li><li class="chapter-item expanded "><a href=".week_9/preface.html"><strong aria-hidden="true">9.</strong> Week 9</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">9.1.</strong> Overview</div></li><li class="chapter-item expanded "><a href="week_9/9-2.html"><strong aria-hidden="true">9.2.</strong> Learning activities</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">9.2.1.</strong> Download and examine</div></li><li class="chapter-item expanded "><a href="week_9/9-2-2.html"><strong aria-hidden="true">9.2.2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="week_9/9-2-3.html"><strong aria-hidden="true">9.2.3.</strong> Shortest Path Algorithms</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="week_9/9-2-3-1.html"><strong aria-hidden="true">9.2.3.1.</strong> Dijkstras Algorithm</a></li><li class="chapter-item expanded "><a href="week_9/9-2-3-2.html"><strong aria-hidden="true">9.2.3.2.</strong> Floyds Algorithm</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.3.</strong> Workshop</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.4.</strong> After Workshop</div></li><li class="chapter-item expanded "><a href="week_9/module-references.html"><strong aria-hidden="true">9.5.</strong> References</a></li></ol></li><li class="chapter-item expanded "><a href=".week_10/preface.html"><strong aria-hidden="true">10.</strong> Week 10</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">10.1.</strong> Overview</div></li><li class="chapter-item expanded "><a href="week_10/10-2.html"><strong aria-hidden="true">10.2.</strong> Learning activities</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">10.2.1.</strong> Download and examine</div></li><li class="chapter-item expanded "><a href="week_10/10-2-2.html"><strong aria-hidden="true">10.2.2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="week_10/10-2-3.html"><strong aria-hidden="true">10.2.3.</strong> Iterative Improvement</a></li><li class="chapter-item expanded "><a href="week_10/10-2-4.html"><strong aria-hidden="true">10.2.4.</strong> Maximum Flow Algorithm</a></li><li class="chapter-item expanded "><a href="week_10/10-2-5.html"><strong aria-hidden="true">10.2.5.</strong> Ford-Fulkerson Algorithm</a></li><li class="chapter-item expanded "><a href="week_10/10-2-6.html"><strong aria-hidden="true">10.2.6.</strong> Efficiency Degradation of the Augmenting Path Method</a></li><li class="chapter-item expanded "><a href="week_10/10-2-7.html"><strong aria-hidden="true">10.2.7.</strong> Shortest Augmenting Path Algorithm</a></li><li class="chapter-item expanded "><a href="week_10/10-2-8.html"><strong aria-hidden="true">10.2.8.</strong> Maximum Bipartite Matching Algorithm</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.3.</strong> Workshop</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.4.</strong> After Workshop</div></li><li class="chapter-item expanded "><a href="week_10/module-references.html"><strong aria-hidden="true">10.5.</strong> References</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">CAB301 Algorithms and Complexity</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="cab301-study-guide--2023-semester-1"><a class="header" href="#cab301-study-guide--2023-semester-1">CAB301 Study Guide | 2023 Semester 1</a></h1>
<p>Dr Maolin Tang | Notes for CAB301 at the Queensland University of Technology</p>
<h2 id="unit-description"><a class="header" href="#unit-description">Unit Description</a></h2>
<h2 id="disclaimer"><a class="header" href="#disclaimer">Disclaimer</a></h2>
<p>Everything written here is based off the QUT course content. However, there are at times parts of text that are taken from the QUT slides and most of the examples are directly from the course slides (these are referenced when done). This content is designed only for those currently studying an IT degree at QUT, do not share these resources with anyone outside of this community.</p>
<p>If any member of the QUT staff or a representative of such finds any issue with these guides please contact me at jeynesbrook@gmail.com and I will take these down without an argument. The last thing I want to do is cause any issues or damages to the QUT name or QUT resources. I am simply just trying to help students out with presenting the content in an easy to digest manor.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="disclaimer-1"><a class="header" href="#disclaimer-1">Disclaimer</a></h2>
<p>All references used within this module can be found within <a href=".week_1/../week_1/module-references.html">References</a>.</p>
<p>The quizzes used within this module are taken directly from the QUT slides, I do not claim 
them as my own work unless directly specified under the quiz.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="learning-activities"><a class="header" href="#learning-activities">Learning activities</a></h1>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="week_1/./1-2-2.html">1.2.2: Introduction</a></li>
<li><a href="week_1/./1-2-3.html">1.2.3: What is an algorithm?</a></li>
<li><a href="week_1/./1-2-4.html">1.2.4: Pseudocode notations</a></li>
<li><a href="week_1/./1-2-5.html">1.2.5: Algorithm efficiency and algorithm analysis</a></li>
<li><a href="week_1/./1-2-6.html">1.2.6: Algorithm analysis - An example</a></li>
<li><a href="week_1/./1-2-7.html">1.2.7: Why do we need to worry about the efficiency of an algorithm</a></li>
<li><a href="week_1/./1-2-8.html">1.2.8: The tower of Hanoi problem</a></li>
<li><a href="week_1/./1-2-9.html">1.2.9: The tower of Hanoi - code example</a></li>
<li><a href="week_1/./1-2-10.html">1.2.10: What are data structures</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-an-algorithm"><a class="header" href="#what-is-an-algorithm">What is an algorithm?</a></h1>
<h2 id="what-is-an-algorithm-1"><a class="header" href="#what-is-an-algorithm-1">What is an algorithm?</a></h2>
<p>An algorithm is a sequence of instructions which can be followed to solve some
computational problem. Due to algorithms being independent of a programming language,
they can typically be implemented into any.</p>
<h2 id="pseudocode"><a class="header" href="#pseudocode">Pseudocode</a></h2>
<p>Pseudocode is a way of writing the steps of an algorithm out in plain text without 
getting stuck by a specific programming language syntax.</p>
<p>Sometimes within pseudocode, we informally describe 'obvious' actions. For example,
within the SelectionSort algorithm, we might just use the term 'swap' to describe
the action.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pseudocode-notations"><a class="header" href="#pseudocode-notations">Pseudocode notations</a></h1>
<div class="table-wrapper"><table><thead><tr><th>Variables</th><th>Meaning</th></tr></thead><tbody>
<tr><td>\(v \), \(w \), ...</td><td>Variable names</td></tr>
<tr><td>\(E \), \(F \), ...</td><td>Expressions</td></tr>
<tr><td>\(B \), \(C \), ...</td><td>Boolean values</td></tr>
<tr><td>\(N \), \(M \), ...</td><td>Integer-valued expressions</td></tr>
<tr><td>\(S \), \(T \), ...</td><td>(Compound) program statements</td></tr>
<tr><td>\(P \), \(Q \), ...</td><td>Procedure names</td></tr>
<tr><td>\(x \), \(y \), ...</td><td>Parameter names</td></tr>
<tr><td>3.1425926, 'c', true</td><td>Primitive types</td></tr>
<tr><td>\(A[i] \)</td><td>Arrays / Vectors</td></tr>
<tr><td>\(\{4, ..., 10\} \)</td><td>Sets</td></tr>
</tbody></table>
</div><br />
<div class="table-wrapper"><table><thead><tr><th>Statements</th><th>Meaning</th></tr></thead><tbody>
<tr><td>\((2v) + x \)</td><td>Expressions</td></tr>
<tr><td>\(P(x, y, ...) \)</td><td>Parameterised procedure declarations</td></tr>
<tr><td>\(P(E, F, ...) \)</td><td>Procedure calls</td></tr>
<tr><td>\(v \leftarrow E \)</td><td>Assignment</td></tr>
<tr><td>\(S \hspace{0.2em} T \) or \(S; T \)</td><td>Sequential composition</td></tr>
<tr><td>return \(E \)</td><td>Return statements</td></tr>
</tbody></table>
</div><br />
<div class="table-wrapper"><table><thead><tr><th>Conditionals</th><th>Meaning</th></tr></thead><tbody>
<tr><td>if \(B \hspace{0.2em} S \) else \(T \)</td><td>Choice</td></tr>
<tr><td>if \(B \hspace{0.2em} S \)</td><td>If-then statements</td></tr>
</tbody></table>
</div><br />
<div class="table-wrapper"><table><thead><tr><th>Iterations</th><th>Meaning</th></tr></thead><tbody>
<tr><td>while \(B \) do \(S \)</td><td>Iteration</td></tr>
<tr><td>for \(v \leftarrow N \) to \(M \)  do \(S \)</td><td>Iteration</td></tr>
<tr><td>repeat \(S \) until \(B \)</td><td>Iteration (post-tested)</td></tr>
</tbody></table>
</div>
<h2 id="pseudocode-example"><a class="header" href="#pseudocode-example">Pseudocode Example</a></h2>
<pre><code>ALGORITHM ArrayMax(A[0..n - 1])
// Given an array A of length n &gt;= 1, 
// return the value of the largest number in A
max &lt;- A[0]
for i &lt;- 1 to n - 1 do
    if A[i] &gt; max
        max &lt;- A[i]
return max
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="algorithm-efficiency-and-algorithm-analysis"><a class="header" href="#algorithm-efficiency-and-algorithm-analysis">Algorithm efficiency and algorithm analysis</a></h1>
<h2 id="algorithm-efficency"><a class="header" href="#algorithm-efficency">Algorithm efficency</a></h2>
<p>Algorithm efficiency is generally represented as a mathematical function which
describes the resource requirements of the algorithm. These requirements describe
the amount of data each algorithm must process before it finishes.</p>
<p>There are two main measures used to describe an algorithms efficiency:</p>
<ol>
<li><strong>Time efficiency</strong>: A mathematical function which describes the amount of time
an algorithm will take to finish in relation to its input.</li>
<li><strong>Space efficiency</strong>: A mathematical function which describes the amount of
space, or storage, an algorithm must take to finish in relation to its input.</li>
</ol>
<h2 id="algorithm-analysis"><a class="header" href="#algorithm-analysis">Algorithm analysis</a></h2>
<p>Algorithm analysis is the process of determining how efficient an algorithm is.</p>
<p>Algorithm analysis is done independent of a language or machine. This is because
the efficiency of an algorithm will change depending on the language implementation
and processing power of the machine.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="algorithm-analysis---an-example"><a class="header" href="#algorithm-analysis---an-example">Algorithm analysis - An example</a></h1>
<p>Let's take a look at an algorithm we've seen previously.</p>
<pre><code>ALGORITHM ArrayMax(A[0..n - 1])
// Given an array A of length n &gt;= 1, 
// return the value of the largest number in A
max &lt;- A[0]              // c1
for i &lt;- 1 to n - 1 do
    if A[i] &gt; max        // c2
        max &lt;- A[i]      // c3
return max               // c4
</code></pre>
<p>In a worst case scenario, the computational time for this algorithm can be
appoximated using the following mathematical function.</p>
<p>\[
T(n) = c1 + (c2+c3)(n-1)+c4
\]</p>
<p>where \(c1, ..., c4 \) are machine dependent, they will always have
the same computation time.</p>
<p>Let's imagine we run this on some machine and time how long it takes to compute
each expression.</p>
<ul>
<li>c1 = 3 micro-seconds</li>
<li>c2 = 2 micro-seconds</li>
<li>c3 = 3 micro-seconds</li>
<li>c4 = 1 micro-seconds</li>
</ul>
<p>\[
T(n) = 3 + (2+3)(n-1)+1 = 5n - 1
\]</p>
<p>We could then say:</p>
<ul>
<li>When \(n = 10\), \(T(10) = 5*10-1 = 49 \) micro-seconds</li>
<li>When \(n = 100\), \(T(100) = 5*100-1 = 499 \) micro-seconds</li>
<li>When \(n = 1000000\), \(T(1000000) = 5*1000000-1 = 4999999 \) micro-seconds</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="why-do-we-need-to-worry-about-the-efficiency-of-an-algorithm"><a class="header" href="#why-do-we-need-to-worry-about-the-efficiency-of-an-algorithm">Why do we need to worry about the efficiency of an algorithm?</a></h1>
<p>If computers are fast and memory cheap, why is there a need to worry about
efficiency?</p>
<p>Consider an algorithm which can solve some problem of size \(n \) by processing
\( 2^n \) cases, \(T(n) = 2^2 \). We now want to implement this on some computer
which takes 0.000000005 seconds per case.</p>
<div class="table-wrapper"><table><thead><tr><th>Problem size</th><th>Solution time</th></tr></thead><tbody>
<tr><td>10</td><td>5.1 micro-seconds</td></tr>
<tr><td>20</td><td>5.2 milli-seconds</td></tr>
<tr><td>30</td><td>5.4 seconds</td></tr>
<tr><td>40</td><td>1.5 hours</td></tr>
<tr><td>50</td><td>9.3 weeks</td></tr>
<tr><td>60</td><td>183 years</td></tr>
<tr><td>70</td><td>1872 centuries</td></tr>
<tr><td>80</td><td>192 million years</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="the-tower-of-hanoi-problem"><a class="header" href="#the-tower-of-hanoi-problem">The tower of Hanoi problem</a></h1>
<h2 id="how-does-the-tower-of-hanoi-problem-work"><a class="header" href="#how-does-the-tower-of-hanoi-problem-work">How does the tower of Hanoi problem work?</a></h2>
<p>Given \(n \) number of rods, and an initial rod stacked with disc incrementally 
getting smaller from bottom to top. The objective is to transfer the entire 
tower from one rod to another under the constraint that:</p>
<ol>
<li>You can only move one disc at a time</li>
<li>You cannot place a disc on one smaller than itself</li>
<li>After any move, all discs must be on a rod</li>
</ol>
<p><img src="week_1/../assets/tower-of-hanoi.png" alt="Tower of Hanoi" /><br />
<strong>Figure: Tower of Hanoi</strong></p>
<h2 id="solving-the-tower-of-hanoi-problem"><a class="header" href="#solving-the-tower-of-hanoi-problem">Solving the tower of Hanoi problem</a></h2>
<p>It's difficult to design an iterative algorithm to solve such a problem. This is
where the power of recursive algorithms come into play.</p>
<pre><code>ALGORITHM TowerOfHanoi(n, a, b, c)
// Find a solution to the problem of moving n disks from rod a to rod c 
// using b as a temporary rod without violating the rules
//
// variables:
//   - n: number of disks
//   - a: starting rod
//   - b: temporary rod
//   - c: end rod

if n &gt; 0
    towerOfHanoi(n - 1, a, c, b)
    move top disk from a to c
    towerOfHanoi(n - 1, b, a, c)
</code></pre>
<p><img src="week_1/../assets/tower-of-hanoi-solved.gif" alt="Tower of Hanoi solution" /><br />
<strong>Figure: Tower of Hanoi solution</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-tower-of-hanoi---code-example"><a class="header" href="#the-tower-of-hanoi---code-example">The Tower of Hanoi - Code example</a></h1>
<p>Here is an implementation of the algorithm to solve the Tower of Hanoi 
problem in C#</p>
<pre><code class="language-csharp">using System;
using System.Diagnostics;

class Program {
    public enum Rod {
        Source,
        Intermediate,
        Destination
    }

    public static void Main() {
        Stopwatch sw = new Stopwatch();

        Console.Write(&quot;Number of disks: &quot;);
        int diskCount = Convert.ToInt32(Console.ReadLine());

        sw.Start();
        TowerOfHanoi(diskCount, Rod.Source, Rod.Intermediate, Rod.Destination);
        sw.Stop();

        Console.WriteLine($&quot;Computation time = {sw.ElapsedMilliseconds} milli-seconds&quot;);
    }

    public static void TowerOfHanoi(int n, Rod source, Rod intermediate, Rod destination) {
        if (n &gt; 0) {
            TowerOfHanoi(n - 1, source, destination, intermediate);
            Console.WriteLine($&quot;Move the top disk from {source} to {destination}&quot;);
            TowerOfHanoi(n - 1, intermediate, source, destination);
        }
    }
}
</code></pre>
<p>All code examples shown in the study guide will be in C# as this is the language 
taught in the unit. However, occasionally, you will see examples of Rust code 
along with C# code. </p>
<p>The engine that runs and formats these study guides only has support for runnable 
Rust code. Therefore, if I want to have runnable code, it needs to be in Rust.</p>
<p>Anytime there is Rust code, you can safely ignore it and just hit the run button
to see the output as it will emulate (for the most part) what the C# code would output.</p>
<p>Be aware however, that it is very easy to timeout the program if the algorithm 
takes too long to run due to the constraints of the books engine.</p>
<pre><pre class="playground"><code class="language-rust editable">use std::fmt;

enum Rod {
    Source,
    Intermediate,
    Destination
}

impl fmt::Display for Rod {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        match self {
            Self::Source =&gt; write!(f, &quot;Source&quot;),
            Self::Intermediate =&gt; write!(f, &quot;Intermediate&quot;),
            Self::Destination =&gt; write!(f, &quot;Destination&quot;),
        }
        
    }
}

fn main() {
    // Change this value here
    let disk_count = 3;

    TowerOfHanoi(disk_count, &amp;Rod::Source, &amp;Rod::Intermediate, &amp;Rod::Destination);
}

fn TowerOfHanoi(n: usize, source: &amp;Rod, intermediate: &amp;Rod, destination: &amp;Rod) {
    if n &gt; 0 {
        TowerOfHanoi(n - 1, source, destination, intermediate);
        println!(&quot;Move the top disk from {} to {}&quot;, source.to_string(), destination.to_string());
        TowerOfHanoi(n - 1, intermediate, source, destination);
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-are-data-structures"><a class="header" href="#what-are-data-structures">What are data Structures?</a></h1>
<p>In computer science, there are many ways to store and organise collections of
data, we call these collections data structures.</p>
<p>There are many data structures such as:</p>
<ul>
<li>Arrays</li>
<li>Linked lists</li>
<li>Binary trees</li>
<li>Trees</li>
<li>Graphs</li>
<li>Hash tables</li>
<li>etc...</li>
</ul>
<p>No single data structure will work for all purposes, hence the need for many.
This is why it's important that you can recognise the strenghs, weaknesses, 
limitations, and use cases for each data strcture.</p>
<p>Throughout the course, we will delve into different algorithms that will require
the use of many different data structures. Overtime you will start to recognise 
and learn when to use each one.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="module-references"><a class="header" href="#module-references">Module References</a></h2>
<p>QUT lectures &amp; slides</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="disclaimer-2"><a class="header" href="#disclaimer-2">Disclaimer</a></h2>
<p>All references used within this module can be found within <a href=".week_2/../week_2/module-references.html">References</a>.</p>
<p>The quizzes used within this module are taken directly from the QUT slides, I do not claim 
them as my own work unless directly specified under the quiz.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="learning-activities-1"><a class="header" href="#learning-activities-1">Learning activities</a></h1>
<h2 id="table-of-contents-1"><a class="header" href="#table-of-contents-1">Table of Contents</a></h2>
<ul>
<li><a href="week_2/./2-2-2.html">2.2.2: Introduction</a></li>
<li><a href="week_2/./2-2-3.html">2.2.3: How to perform a theoretical analysis of algorithm efficiency</a></li>
<li><a href="week_2/./2-2-4.html">2.2.4: Big-O notation</a></li>
<li><a href="week_2/./2-2-5.html">2.2.5: Algorithm analysis - An example</a></li>
<li><a href="week_2/./2-2-6.html">2.2.6: Derive algorithm efficiency from its structure</a></li>
<li><a href="week_2/./2-2-7.html">2.2.7: Empirical analysis of an algorithms efficiency</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h1>
<h2 id="analysis-of-algorithms"><a class="header" href="#analysis-of-algorithms">Analysis of Algorithms</a></h2>
<p>Algorithm analysis is the process of determining how efficient an algorithm is.</p>
<p>There are two ways to measure how efficient an algorithm is:</p>
<ol>
<li>Theoretical analysis</li>
<li>Empirical analysis</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-perform-a-theoretical-analysis-of-algorithm-efficiency"><a class="header" href="#how-to-perform-a-theoretical-analysis-of-algorithm-efficiency">How to perform a theoretical analysis of algorithm efficiency</a></h1>
<h2 id="what-are-the-steps"><a class="header" href="#what-are-the-steps">What are the steps?</a></h2>
<p>There are a series of steps we can take when attempting to perform a theoretical
analysis on some algorithm.</p>
<ol>
<li>Plan out the parameter(s), characterising the size of input.</li>
<li>Identify the algorithms basic operation(s).</li>
<li>Setup a summation formula for the number of times the basic operation(s) are
performed in a worst-case scenario.</li>
<li>Solve the summation formula. This will result in either an exact equation or
an identification of the algorithms efficiency class in big-O notation.</li>
</ol>
<h2 id="step-1-what-is-the-size-of-input"><a class="header" href="#step-1-what-is-the-size-of-input">Step 1: What is the size of input?</a></h2>
<p>The input size for the algorithm will depend on what data structures are involved.
For example, when dealing with compound data structures, the input size is usually
just the number of components involved:</p>
<ul>
<li>The number of tiems in an array</li>
<li>The dimensions of a matrix</li>
<li>The number of nodes or edges in a graph</li>
</ul>
<p>Sometimes the input size of an algorithm is defined with two or more parameters.</p>
<ul>
<li>The two dimensions of a matrix</li>
<li>The number of nodes and the number of edges in a graph</li>
</ul>
<h2 id="step-2-what-are-the-basic-operations-required"><a class="header" href="#step-2-what-are-the-basic-operations-required">Step 2: What are the basic operations required?</a></h2>
<p>A basic operation is an operation that will have the most influence on the
algorithms total computation time:</p>
<ul>
<li>Key comparisons in a searching algorithm</li>
<li>Numeric multiplications in a matrix multiplication algorithm</li>
<li>Visits to nodes (or edges) in a graph traversal algorithm</li>
</ul>
<p>An algorithm will usually have multiple basic operations throughout it's process.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<pre><code>ALGORITHM MaxMin2(A[0..n-1], Max, Min)
// Finds the maximum and minimum numbers in 
// an array A of n numbers, where n &gt;= 1

Max &lt;- A[0]
Min &lt;- A[0]

for i &lt;- 1 to n-1 do
    if A[i] &gt; Max
        Max &lt;- A[i]
    else
        if A[i] &lt; Min
            Min &lt;- A[i]
</code></pre>
<h3 id="step-1-find-the-input-size"><a class="header" href="#step-1-find-the-input-size">Step 1: Find the input size</a></h3>
<p>Our input size for the algorithm would be the length of \(A[0..n-1] \). 
The size of \(A \) will change the amount of the time the algorithm will take 
to run. This is because the length essentially represent the amount of times 
the algorithm will need to iterate.</p>
<h3 id="step-2-find-the-basic-operations"><a class="header" href="#step-2-find-the-basic-operations">Step 2: Find the basic operations</a></h3>
<p>The basic operations in this algorithm would be the two comparison statements:</p>
<ul>
<li><code>if A[i] &gt; Max</code> </li>
<li><code>if A[i] &lt; Min</code> </li>
</ul>
<p>This is because these operations will be performed most of the time during this
algorithm.</p>
<h3 id="step-3-create-a-summation-formula"><a class="header" href="#step-3-create-a-summation-formula">Step 3: Create a summation formula</a></h3>
<p>Putting this together we can say that the worst case scenario is when the first
array element \(A[0] \) contains the largest number in the array. This is
because it means the second <code>if</code> statement is always peformed.</p>
<p>In this situation, the basic operation is performed twice for each iteration
of the loop. Therefore the algorithms worst-case efficiency function is described
as:</p>
<p>\[
C_{worst}(n) = \sum_{i=1}^{n-1} 2 = 2 \sum_{i=1}^{n-1} 1 = 2(n-1) = 2n - 2
\]</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="big-o-notation"><a class="header" href="#big-o-notation">Big-O notation</a></h1>
<p>Big-O notation is a way of describing the worst-case scenario speed 
and/or complexity of a given algorithm.</p>
<p>Let \(O(g(n)) \) be a class containing all functions that are bound above
by some multiple \(c \) of \(g(n) \). If some function \(t(n) \) is in
the class \(O(g(n)) \) then it's worst-case behaviour is bound by a function
with the same 'shape' as \(g(n) \).</p>
<p>For example, say we have algorithm that takes \(T \) time to finish.</p>
<p>\[
T(n) = 4n^2 - 2n + 2
\]</p>
<p>Ignoring constants, we could say that \(T(n) \) grows at an order of \(n^2 \)
and therefore write:</p>
<p>\[
T(n) = O(n^2)
\]</p>
<p>Big-O notation ignores fine details such as multiplicative constants, bases of
logarithms, and low-order terms in polynomials. Regardless of this, they are
still sufficient enough to distinguish between acceptable algorithms and unacceptable
ones.</p>
<p>For example, an \(O(n) \) algorithm will outperform an \(O(n^2) \) on average for large
inputs</p>
<p><img src="week_2/../assets/big-o.png" alt="Big-O diagram" />
<strong>Figure: Big-O notation</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="algorithm-analysis---an-example-1"><a class="header" href="#algorithm-analysis---an-example-1">Algorithm analysis - An example</a></h1>
<pre><code>ALGORITHM UniqueElements(A[0.n-1])
// Determines whether all elements in a given array are distinc
// Input: An array A[0..n-1]
// Output: true if all elements are distinct and false otherwise

for i &lt;- 0 to n - 2 do
    for j &lt;- i + 1 to n - 1 do
        if A[i] = A[j] return false

return true
</code></pre>
<p>The worst case scenario for this algorithm is when all elements in \(A \) are
unique. The basic operation in this algorithm occurs within the innermost loop
where the two elements are compared.</p>
<p>The innermost loop occurs for \(j \) equal to \(i + 1 \) to n-1, 
inclusive.</p>
<p>\[
\sum_{j=i+1}^{n-1} 1 = (n-1) - (i+1) + 1 = n - i - 1
\]</p>
<p>The outermost loop occurs for \(i \) equal to \(0 \) to \(n - 2 \), inclusive.</p>
<p>\[
\sum_{i=0}^{n-2} (n-1-j) = (n-1) - (n-2) + \dots + 1 = \sum_{i=1}^{n-1} i = \frac{n(n-1)}{2}
\]</p>
<p>Therefore, the algorithms worst-case efficiency is:</p>
<p>\[
C_{worst}(n) = \frac{(n-1)n}{2} = \frac{1}{2}n^2 - \frac{1}{2}n \in O(n^2)
\]</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="derive-algorithm-efficiency-from-its-structure"><a class="header" href="#derive-algorithm-efficiency-from-its-structure">Derive algorithm efficiency from its structure</a></h1>
<p>Sometimes, it's possible to identify an algoriths efficiency class based on
the pseudocodes structure.</p>
<p>For example, assigments such as \(v \leftarrow E \) are usually assumed to
take constant time, \(O(1) \).</p>
<p>Saying that, there will still be times where we may need to produce summations
or recurrence relations in order to determine the efficency class accurately.</p>
<h2 id="independent-loops"><a class="header" href="#independent-loops">Independent loops</a></h2>
<p>Loops that iterate a fixed number of times have their loop body executed in
direct proportion to the loops variable range.</p>
<pre><code>for j &lt;- 0 to n - 1 do  \ O(n) 
    x &lt;- x + 1          /
</code></pre>
<p>Nested loops are analysed from the innermost to the outermost</p>
<pre><code>for i &lt;- 0 to n - 1 do             \
    for j &lt;- 0 to n - 1 do  \ O(n)  | O(n^2)
        x &lt;- x + 1          /      /
</code></pre>
<h2 id="dependent-loops"><a class="header" href="#dependent-loops">Dependent loops</a></h2>
<p>Dependent loops occur when a loop variable depends on another. In these cases
we need to produce a summation to accurately identify the efficiency class.</p>
<pre><code>for i &lt;- 0 to n - 1 do                 \
    for j &lt;- i to n - 1 do  \ O(n-i)    | O(n^2) 
        x &lt;- x + 1          /          /
</code></pre>
<p>\[
\sum_{i=0}^{n-1}((n-1)-i+1) = \sum_{i=0}^{n-1} (n-i) = n + (n-1) + \dots + 1 = \sum_{i=1}^{n} i = \frac{n(n+1)}{2} = \frac{1}{2}n^2 + \frac{1}{2}n \in O(n^2)
\]</p>
<h2 id="iteration-with-uneven-steps"><a class="header" href="#iteration-with-uneven-steps">Iteration with uneven steps</a></h2>
<p>Loops where the size of steps increase/decrease by a power have a logarithmic
or exponential growth.</p>
<pre><code>i &lt;- 1

while i &lt; n do                            \
    for j &lt;- 0 to n - 1 do  \ O(n) \       \ O(n log n)
        x &lt;- x + 1          /      | O(n)  /
    i &lt;- i * 2     // O(1)         /      /
</code></pre>
<p>\[
\sum_{x=1}^k n = n \cdot k = n \cdot \log_2 n \in O(n \log n)
\]</p>
<h2 id="balanced-loops"><a class="header" href="#balanced-loops">Balanced loops</a></h2>
<p>In certain situations, two nested loops can counter-balance themselves leading
to a 'obvious' result in an non-obvious way.</p>
<pre><code>i &lt;- 1

while i &lt; n do                         \
    for j &lt;- 1 to i do  \ O(i) \        \ O(n)
        x &lt;- x + 1      /       | O(i)  /
    i &lt;- i * 2    // O(1)      /       /
</code></pre>
<p>\[
\sum_{x=0}^{k-1} 2^x = 2^{(k-1)+1} - 1 = 2^k - 1 = n - 1 \in O(n)
\]</p>
<h2 id="sequential-composition"><a class="header" href="#sequential-composition">Sequential composition</a></h2>
<p>For sequential statements, \(S_1, S_2, ..., S_k \), the total efficiency
is the sum of the individual statements efficiencies. However, the overall
order of growth is determined by the largest polynomial term for any individual
statement.</p>
<p>For example,</p>
<pre><code>for i &lt;- 0 to n - 1 do  \ O(n)        \
    x &lt;- x + 1          /              \
                                        \ O(n^2)
for i &lt;- 0 to n - 1 do      \           /
    for j &lt;- 0 to n - 1 do   | O(n^2)  /
        x &lt;- x + 1          /         /
</code></pre>
<h2 id="conditionals"><a class="header" href="#conditionals">Conditionals</a></h2>
<p>The worst-case order of growth for a conditional is the largest, most expensive, 
path that could be taken.</p>
<pre><code>if B             \
    S_1 // O(m)   \ O(max(m, n))
else              /
    S_2 // O(n)  /
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="empirical-analysis-of-an-algorithms-efficiency"><a class="header" href="#empirical-analysis-of-an-algorithms-efficiency">Empirical analysis of an algorithms efficiency</a></h1>
<p>After confirming theoretically that an algorithms effiency is acceptable, we
may still wnat to analyse it's behaviour in its intended environment. Doing 
this allows us to see whether the algorithm works worse than we expected or 
sometimes even better than what we expected.</p>
<p>There are seven steps typically taken when analysing an algorithms efficiency</p>
<p><strong>Step 1</strong><br />
The first step we take is understanding what the purpose of the experiment it.
Are we trying to:</p>
<ul>
<li>Check the accuracy of a theoretical assertion</li>
<li>Compare the efficiency of several algorithms in solving the same problem</li>
<li>Compare different implementations of the same algorithm</li>
<li>Develop a hypothesis about an algorithms efficiency class</li>
<li>Ascertain the efficiency of the program implenting the algorithm</li>
</ul>
<p><strong>Step 2</strong><br />
The second step is to determine the efficiency metric to be measured and what unit
is to be used. There are two common efficiency metrics:</p>
<ol>
<li>The number of times the algorithms basic operation is executed</li>
<li>The execution time of the algorithms implementation</li>
</ol>
<p><strong>Step 3</strong><br />
The third step is to decide on the characteristics for the input sample. This
involves determining the problem size parameter(s) and then identifying the
basic operation and all instances of it.</p>
<p><strong>Step 4</strong><br />
The fourth step involves implementing and testing the algorithm within a program.
Start by choosing a programming language and implement the algorithm in it. Then
test to ensure none of the expected behavours have changed. </p>
<p>It's important that the program counting the number of times the basic operation 
is performed and the program that is used to test the execution time are seperate.</p>
<p>A systems timer is typically not accurate, you will usually get different results
on repeated runs of the same program. This is why it's important to run the program
multiple times and take the average time of the recorded runs.</p>
<p>Sometimes, the running time of the algorithm may fail to register and report 0
because it's too fast. In instances like so, it's typical to run the algorithm
multiple times within a loop and divide the total time by the amount of repetitions.</p>
<p><strong>Step 5</strong><br />
The fifth step involves generating a series of sample inputs. If there are aleady
benchmarks that exist, you can use those. However, if there are none, then you will
need to make a few decisions:</p>
<ol>
<li>What will be the range of input sizes</li>
<li>What will be the size of the sample inputs</li>
<li>How many times will each case need to be repeated</li>
</ol>
<p>Depending on the use-case, it may be useful to develop a program which randomly
generates a sample of inputs.</p>
<p><strong>Step 6</strong><br />
Step six involves actually running the algorithm and recording the data observed.</p>
<p><strong>Step 7</strong><br />
The final step in this process is to analyse the data recorded in the previous step.
It's a good idea to present the data observed in both methods as each method
carries its own strengths and weaknesses.</p>
<p>There are a few ways that we can present the data to be analysed:</p>
<ul>
<li>Numerically within a table. Tabular presentations are good as they allow for 
easy data manipulation.</li>
<li>Numerically within a graph, i.e. scatterplot
<ul>
<li>Scatterplots are a good way of showing the results as they allow for an easy
visual assertion of the algorithms efficiency class</li>
</ul>
</li>
</ul>
<p>Let's see an example, imagine we ran some algorithm and recorded the following results.</p>
<div class="table-wrapper"><table><thead><tr><th>Size</th><th>Count</th></tr></thead><tbody>
<tr><td>1000</td><td>11_966</td></tr>
<tr><td>2000</td><td>24_303</td></tr>
<tr><td>3000</td><td>39_992</td></tr>
<tr><td>4000</td><td>53_010</td></tr>
<tr><td>5000</td><td>67_272</td></tr>
<tr><td>6000</td><td>78_692</td></tr>
<tr><td>7000</td><td>91_274</td></tr>
<tr><td>8000</td><td>113_063</td></tr>
<tr><td>9000</td><td>129_799</td></tr>
<tr><td>10000</td><td>140_538</td></tr>
</tbody></table>
</div>
<p>We could then analyse the data like so:</p>
<p>\[
\frac{t(10000)}{t(5000)} = \frac{140538}{67272} = 2.089 
\]</p>
<p>\[
\frac{t(8000)}{t(4000)} = \frac{113063}{53010} = 2.133 
\]</p>
<p>Observations:</p>
<ul>
<li>Since the ration of \(t(2n) \) and \(t(n) \) is greater than 2, we know
the algorithm is less efficient than \(O(n) \).</li>
<li>Since the ration is less than 4, we know the algorithm is more efficient than
\(O(n^2) \).</li>
</ul>
<p>Based off the two observations above, we can conclude that the efficiency class
is somewhere between \(O(n) \) and \(O(n^2) \). \(O(n \log n) \) is such an
efficiency class.</p>
<p>\[
\frac{t(2n)}{t(n)} = \frac{c(2n)}{cn} = 2
\]</p>
<p>\[
\frac{t(2n)}{t(n)} = \frac{c(2n)^2}{cn^2} = \frac{4cn^2}{cn^2} = 4
\]</p>
<p>We can then check the experimental results and confirm that the efficiency class
is \(O(n \log n) \).</p>
<p>\[
\frac{t(2n)}{t(n)} = \frac{(2n) \log (2n)}{n \log n} = \frac{2 \log (2n)}{\log n}
\]</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="module-references-1"><a class="header" href="#module-references-1">Module References</a></h2>
<p>QUT lectures &amp; slides</p>
<p>Big O Notation Explained with Examples. (2020, February 1). FreeCodeCamp.org. https://www.freecodecamp.org/news/big-o-notation-explained-with-examples/</p>
<p>Big-O notation. (2018). Big-O notation. Khan Academy. https://www.khanacademy.org/computing/computer-science/algorithms/asymptotic-notation/a/big-o-notation</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="disclaimer-3"><a class="header" href="#disclaimer-3">Disclaimer</a></h2>
<p>All references used within this module can be found within <a href=".week_3/../week_3/module-references.html">References</a>.</p>
<p>The quizzes used within this module are taken directly from the QUT slides, I do not claim 
them as my own work unless directly specified under the quiz.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="learning-activities-2"><a class="header" href="#learning-activities-2">Learning activities</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-2"><a class="header" href="#introduction-2">Introduction</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arrays"><a class="header" href="#arrays">Arrays</a></h1>
<p>An array is an elementary linear data structure used to store a sequence of
\(n\) items of the same data type.</p>
<p>Every element within an array can be accessed in constant time via the items index.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linked-lists"><a class="header" href="#linked-lists">Linked Lists</a></h1>
<p>A linked list is a sequence of zero or more elements called nodes. Each node
consists of:</p>
<ul>
<li>An item</li>
<li>A pointer to the next item in the list or <code>null</code> if there is no next item</li>
</ul>
<p>Linked links are dynamic data structures, the length of itself is the number of
nodes the linked list contains.</p>
<p>There are two main types of linked lists:</p>
<ul>
<li><strong>Single Linked List</strong>: Each node, excluding the last, contains a single pointer
to the next node</li>
<li><strong>Double Linked List</strong>: Each node, excluding the first and last, contains a 
pointer to its successor and its predecessor.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arrays-vs-linked-lists"><a class="header" href="#arrays-vs-linked-lists">Arrays vs Linked Lists</a></h1>
<h2 id="similarities"><a class="header" href="#similarities">Similarities</a></h2>
<ul>
<li>Both, arrays and linked lists, can be used to implement a more abstract data-structure
called a list</li>
</ul>
<h2 id="differences"><a class="header" href="#differences">Differences</a></h2>
<ul>
<li>To access the \(n^{\text{th}}\) element:
<ul>
<li>in an array, we must index the array by \(n\)</li>
<li>in a linked list, we must step through the first \(n-1\) nodes</li>
</ul>
</li>
<li>To insert an item to the beginning of:
<ul>
<li>an array, we must first move all the elements in the array before we can
insert the item. This is not efficient for larger arrays - \(O(n)\).</li>
<li>a linked list, we can directly insert the item in the beginning and point
to the previous first item. This is very efficient - \(O(1)\).</li>
</ul>
</li>
<li>To delete an item from:
<ul>
<li>an array, once the item has been removed, we must move all the items - \(O(n)\)</li>
<li>a linked list, once the item has been removed, we must traverse the pointer 
chain to find both the successor and predessor and update their pointers - \(O(n)\)</li>
</ul>
</li>
<li>To search an item:
<ul>
<li>in an array, we search the array sequentially or use some binary search if
the elements are sorted - \(O(n)\) for linear search and \(O(\log n)\) for binary search.</li>
<li>in a linked list, we need to traverse the pointer chain to find the node
where the item is sored - \(O(n)\).</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stacks"><a class="header" href="#stacks">Stacks</a></h1>
<p>A stack is a linear data structure following LIFO (Last In First Out) that stores 
items sequentially only allowing access to the element on the top.</p>
<ul>
<li>To add an item we push it onto the top of the stack</li>
<li>To remove an item we pop it off the top of the stack</li>
</ul>
<p>This means that we don't have access to the items contained within the middle of
the stack.</p>
<h2 id="stack-applications"><a class="header" href="#stack-applications">Stack Applications</a></h2>
<p>We can use stacks in a variety of ways such as:</p>
<ul>
<li>Checking parenthesis matching in an expression</li>
<li>Expressing evaluation</li>
<li>Conversion from one form of expression to another</li>
<li>Memory management</li>
<li>Backtracking algorithms</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="queues"><a class="header" href="#queues">Queues</a></h1>
<p>A queue is a linear data structure following FIFO (First In First Out).</p>
<ul>
<li>To add an item we use the enqueue operation adding it onto the tail of the stack</li>
<li>To remove an item we use the dequeue operation removing it from the head of the stack</li>
</ul>
<p>This means that we don't have access to the items contained within the middle of
the stack.</p>
<h2 id="queue-applications"><a class="header" href="#queue-applications">Queue Applications</a></h2>
<p>We can use queues in a variety of ways such as:</p>
<ul>
<li>Algorithm design</li>
<li>CPU scheduling</li>
<li>Disk scheduling</li>
<li>Managing shared resources between various processes</li>
<li>Data transferring between IO buffers</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="search-algorithms"><a class="header" href="#search-algorithms">Search Algorithms</a></h1>
<p>Searching algorithms are 'comparison based' algorithms where searching is done
either to confirm a certain item exists in a collection or to find an item labelled
with a given key. This is usually done by comparing an item in the collection 
with the search key.</p>
<p>There are two classical search algorithms:</p>
<ul>
<li>Sequential search algorithm</li>
<li>Binary search algorithm</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sequential-search"><a class="header" href="#sequential-search">Sequential Search</a></h1>
<p>Sequential search algorithms can almost be thought of as the brute force method
of finding some item. We systematically examine each item in turn until the desired
one is found or we run out of items to check.</p>
<p>This is the only algorithm possible when the collection is unsorted. The worst
case scenario is all items must be inspected.</p>
<h2 id="pseudocode-1"><a class="header" href="#pseudocode-1">Pseudocode</a></h2>
<pre><code>ALGORITHM SequentialSearch(A[0..n-1], K)
// Searches for a given value in a given array by sequential search
// Input:
//     - An array A[0..n-1]
//     - A search key K
// Output:
//     - The index of the first element of A that matches K or -1 if no match
i &lt;- 0
while i &lt; n and A[i] != K do
    i &lt;- i + 1

    if i &lt; n return i
    else return -1

</code></pre>
<h2 id="efficiency"><a class="header" href="#efficiency">Efficiency</a></h2>
<p>In the case of sequential search, we choose the comparison \(A[i] \neq K\) as
the basic operation. We also assume that this comparison is not performed if the
first conjunct \(i &lt; n\) is false.</p>
<p>The worst case in this scenario is when key \(K\) does not appear in the array
\(A\) at all, or is the last item within the array. This scenario forces the algorithm
to inspect every element within the array.</p>
<p>\[
C_{worst}(n) = n \in O(n)
\]</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="binary-search"><a class="header" href="#binary-search">Binary Search</a></h1>
<p>If we know that the collection of items will be sorted, we can use a decrease-and-conquer
algorithm.</p>
<p>A decrease-and-conquer algorithm decreases the problem instance into a smaller
instance of the same problem, conquering the larger problem by solving the smaller
instance.</p>
<p>A binary search algorithm is an algorithm that does such a thing.</p>
<ol>
<li>Choose the midpoint of the array</li>
<li>If the item of interest is there, then the search is done</li>
<li>If the search key is smaller than the selected value at the midpoint, repeat
the search on the lower half of the array</li>
<li>If the search key is larger than the selected value at the midpoint, repeat
the search on the upper half of the array</li>
</ol>
<h2 id="pseudocode-2"><a class="header" href="#pseudocode-2">Pseudocode</a></h2>
<pre><code>ALGORITHM BinarySearch(A[0..n-1], K)
// Implements a non-recursive binary search
// Input:
//     - An array A[0..n-1] sorted in ascending order
//     - A search key K
// Output:
//     - The index of the first element of A that matches K or -1 if no match
i &lt;- 0; r &lt;- n - 1

while l &lt;= r do
    m &lt;- floor((l + r) / 2)
    if K = A[m] return m
    else if K &lt; A[m] r &lt;- m - 1
    else l &lt;- m + 1

return -1
</code></pre>
<h2 id="efficiency-1"><a class="header" href="#efficiency-1">Efficiency</a></h2>
<p>\[
C_{worst}(n) = \log_2 n + 1 \in O(\log n)
\]</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="module-references-2"><a class="header" href="#module-references-2">Module References</a></h2>
<p>QUT lectures &amp; slides</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="disclaimer-4"><a class="header" href="#disclaimer-4">Disclaimer</a></h2>
<p>All references used within this module can be found within <a href=".week_4/../week_4/module-references.html">References</a>.</p>
<p>The quizzes used within this module are taken directly from the QUT slides, I do not claim 
them as my own work unless directly specified under the quiz.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="learning-activities-3"><a class="header" href="#learning-activities-3">Learning activities</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-3"><a class="header" href="#introduction-3">Introduction</a></h1>
<h2 id="sorting-algorithms"><a class="header" href="#sorting-algorithms">Sorting Algorithms</a></h2>
<p>Sorting algorithms are 'comparison-based' algorithsm where the aim is to arrange
a collection of items in some defined order. This is usual achieved via the swapping
of items within the collection.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stable-sorting-algorithms"><a class="header" href="#stable-sorting-algorithms">Stable sorting algorithms</a></h1>
<h2 id="sorting-algorithm-applications"><a class="header" href="#sorting-algorithm-applications">Sorting Algorithm Applications</a></h2>
<p>Let's imagine that we have some collection of <code>Person</code> objects.</p>
<pre><pre class="playground"><code class="language-rust">struct Person&lt;'a&gt; {
    first_name: &amp;'a str,
    family_name: &amp;'a str,
}

impl&lt;'a&gt; Person&lt;'a&gt; {
    fn new(first_name: &amp;'a str, family_name: &amp;'a str) -&gt; Self {
        Self {
            first_name,
            family_name
        }
    }
}

fn main() {
    let array = [
        Person::new(&quot;John&quot;, &quot;Doe&quot;), 
        Person::new(&quot;Jane&quot;, &quot;Smith&quot;), 
        Person::new(&quot;Jacob&quot;, &quot;Brown&quot;)
    ];
}</code></pre></pre>
<p>Our goal is to sort the array in alphabetical order however, because the <code>Person</code> 
class lacks a comparison method we can't do this out-of-the-box. </p>
<p>We can achieve this using a stable sorting algorithm. First, we sort each <code>Person</code>
in the array by their first name, then we by their last name.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="insertion-sort"><a class="header" href="#insertion-sort">Insertion Sort</a></h1>
<h2 id="algorithm"><a class="header" href="#algorithm">Algorithm</a></h2>
<pre><code>ALGORITHM InsertionSort(A[0..n-1])
// Sorts a given array by Insertion sort
// Input: An array A[0..n-1] of n orderable elements
// Output: Array A[0..n-1] sorted in non-decreasing order
for i &lt;- 1 to n - 1 do
    v &lt;- A[i]
    j &lt;- i - 1

    while j &gt;= 0 and A[j] &gt; v do
        A[j+1] &lt;- A[j]
        j &lt;- j - 1

    A[j+1] &lt;- v
</code></pre>
<h2 id="efficiency-2"><a class="header" href="#efficiency-2">Efficiency</a></h2>
<p>\[
C_{worst}(n) = \sum_{i=1}^{n-1}\sum_{j=0}^{i-1}1 = \sum_{i=1}^{n-1}i = \frac{(n-1)n}{2} \in O(n^2)
\]</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="selection-sort"><a class="header" href="#selection-sort">Selection Sort</a></h1>
<p>The general steps this algorithm takes follows as:</p>
<ol>
<li>Find the minimum data item in a list of \(n\) elements</li>
<li>Swap the minimum data item with the item in the first location in the list</li>
<li>Repeat the above steps for the last \(n-1\) elements</li>
</ol>
<h2 id="algorithm-1"><a class="header" href="#algorithm-1">Algorithm</a></h2>
<pre><code>ALGORITHM SelectionSort(A[0..n-1])
// Sorts a given array by selection sort
// Input: An array A[0..n-1] of orderable elements
// Output: Array A[0..n-1] sorted in ascending order

for i &lt;- 0 to n - 2 do
    min &lt;- i

    for j &lt;- i + 1 to n - 1 do
        if A[j] &lt; A[min]
            min &lt;- j
        
        swap A[i] and A[min]
</code></pre>
<h2 id="efficiency-3"><a class="header" href="#efficiency-3">Efficiency</a></h2>
<p>\[
C(n) = \sum_{i=0}^{n-2}\sum_{j=i+1}^{n-1}1 = \sum_{i=0}^{n-2}(n-1-i) = \frac{(n-1)n}{2} \in O(n^2)
\]</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bubble-sort"><a class="header" href="#bubble-sort">Bubble Sort</a></h1>
<p>The basic idea behind a bubble sort is to systematically exchange pairs of data
items in the list that are out of order until eventually no such pairs remain in
the list. Once all pairs in the list are in order, the list is sorted.</p>
<h2 id="algorithm-2"><a class="header" href="#algorithm-2">Algorithm</a></h2>
<pre><code>ALGORITHM BubbleSort(A[0..n-1])
// Sorts a given array by bubble sort
// Input: An array A[0..n-1] of orderable elements
// Output: Array A[0..n-1] sorted in non-decreasing order

for i &lt;- 0 to n - 2 do
    for j &lt;- 0 to n - 2 - i do
        if A[j+1] &lt; A[j] swap A[j] and A[j+1]
</code></pre>
<h2 id="efficiency-4"><a class="header" href="#efficiency-4">Efficiency</a></h2>
<p>\[
C(n) = \sum_{i=0}^{n-2}\sum_{j=0}^{n-2-i}1 = \sum_{i=0}^{n-2}[(n-2-i)-0+1] \\
= \sum_{i=0}^{n-2}(n-1-i) = \frac{(n-1)n}{2} \in O(n^2)
\]</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="module-references-3"><a class="header" href="#module-references-3">Module References</a></h2>
<p>QUT lectures &amp; slides</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="disclaimer-5"><a class="header" href="#disclaimer-5">Disclaimer</a></h2>
<p>All references used within this module can be found within <a href=".week_5/../week_5/module-references.html">References</a>.</p>
<p>The quizzes used within this module are taken directly from the QUT slides, I do not claim 
them as my own work unless directly specified under the quiz.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="learning-activities-4"><a class="header" href="#learning-activities-4">Learning activities</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-4"><a class="header" href="#introduction-4">Introduction</a></h1>
<h2 id="binary-tree"><a class="header" href="#binary-tree">Binary Tree</a></h2>
<p>A binary tree is a non-linear data structure in which each node has at most two 
children.</p>
<pre class="mermaid">graph TD
    A((A)) --&gt; B((B))
    A((A)) --&gt; C((C))
    B((B)) --&gt; D((D))
    B((B)) --&gt; E((E))
    C((C)) --&gt; F((F))
    F((F)) --&gt; G((G))
    G((G)) --&gt; H((H))
</pre>
<p>In mathematical terms we could describe a binary tree as a set of \(T\) nodes
such that either:</p>
<ul>
<li>\(T\) is empty</li>
<li>\(T\) is partitioned into three disjoint subsets
<ul>
<li>A single node root</li>
<li>Two possible empty sets called left and right subtrees of the root</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="binary-tree-implementation"><a class="header" href="#binary-tree-implementation">Binary Tree Implementation</a></h1>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<p>A binary tree structure needs to hold three attributes:</p>
<ul>
<li>The item</li>
<li>The left child pointer</li>
<li>The right child pointer</li>
</ul>
<p>For example,</p>
<pre><code class="language-csharp">class BinaryTree {
    int value
    BinaryTree left;
    BinaryTree right;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="binary-tree-traversal"><a class="header" href="#binary-tree-traversal">Binary Tree Traversal</a></h1>
<h2 id="traversal"><a class="header" href="#traversal">Traversal</a></h2>
<p>Often, we need the ability to visit each node within a binary tree and examine
the stored value. There are three common orders in which we can achieve this,
each with their own strengths and weaknesses.</p>
<ol>
<li>Pre-order</li>
<li>In-order</li>
<li>Post-order</li>
</ol>
<h2 id="pre-order-traversal"><a class="header" href="#pre-order-traversal">Pre-order Traversal</a></h2>
<p>We can recursively define pre-order traversal as:</p>
<ol>
<li>Start at the root</li>
<li>Traverse the left sub-tree in pre-order</li>
<li>Traverse the right sub-tree in pre-order</li>
</ol>
<p>For example, given the following binary tree,</p>
<pre class="mermaid">graph TD
    A((A)) --&gt; B((B))
    A((A)) --&gt; C((C))
    B((B)) --&gt; D((D))
    B((B)) --&gt; E((E))
    C((C)) --&gt; F((F))
    F((F)) --&gt; G((G))
    G((G)) --&gt; H((H))
</pre>
<p>Pre-order would traverse it as such: A B D E C F G H</p>
<h3 id="algorithm-3"><a class="header" href="#algorithm-3">Algorithm</a></h3>
<pre><code>ALGORITHM Pre-order(root)
if root != null
    visit root.item
    Pre-order(root.lchild)
    Pre-order(root.rchild)
</code></pre>
<p>Pre-order has an efficiency of \(O(n)\), where \(n\) represents the number of
nodes within the binary tree.</p>
<h2 id="in-order-traversal"><a class="header" href="#in-order-traversal">In-order Traversal</a></h2>
<p>We can recursively define in-order traversal as:</p>
<ol>
<li>Traverse the left sub-tree in-order</li>
<li>Visit the root</li>
<li>Traverse the right sub-tree in-order</li>
</ol>
<p>For example, given the following binary tree,</p>
<pre class="mermaid">graph TD
    A((A)) --&gt; B((B))
    A((A)) --&gt; C((C))
    B((B)) --&gt; D((D))
    B((B)) --&gt; E((E))
    C((C)) --&gt; F((F))
    F((F)) --&gt; G((G))
    G((G)) --&gt; H((H))
</pre>
<p>In-order would traverse it as such: D B E A C G H F</p>
<h3 id="algorithm-4"><a class="header" href="#algorithm-4">Algorithm</a></h3>
<pre><code>ALGORITHM In-order(root)
if root != null
    In-order(root.lchild)
    visit root.item
    In-order(root.rchild)
</code></pre>
<p>In-order has an efficiency of \(O(n)\), where \(n\) represents the number of
nodes within the binary tree.</p>
<h2 id="post-order-traversal"><a class="header" href="#post-order-traversal">Post-order Traversal</a></h2>
<p>We can recursively define post-order traversal as:</p>
<ol>
<li>Traverse the left sub-tree in post-order</li>
<li>Traverse the right sub-tree in post-order</li>
<li>Visit the root</li>
</ol>
<p>For example, given the following binary tree,</p>
<pre class="mermaid">graph TD
    A((A)) --&gt; B((B))
    A((A)) --&gt; C((C))
    B((B)) --&gt; D((D))
    B((B)) --&gt; E((E))
    C((C)) --&gt; F((F))
    F((F)) --&gt; G((G))
    G((G)) --&gt; H((H))
</pre>
<p>Post-order would traverse it as such: D B E H G F C A</p>
<h3 id="algorithm-5"><a class="header" href="#algorithm-5">Algorithm</a></h3>
<pre><code>ALGORITHM Post-order(root)
if root != null
    Post-order(root.lchild)
    Post-order(root.rchild)
    visit root.item
</code></pre>
<p>Post-order has an efficiency of \(O(n)\), where \(n\) represents the number of
nodes within the binary tree.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="binary-search-tree-search"><a class="header" href="#binary-search-tree-search">Binary Search Tree: Search</a></h1>
<h2 id="binary-search-tree"><a class="header" href="#binary-search-tree">Binary Search Tree</a></h2>
<p>A binary search tree is a binary tree where:</p>
<ul>
<li>Every nodes left sub-tree contains values that are less than or equal to the nodes value</li>
<li>Every nodes right sub-tree contains values that are greater than or equal to the nodes value</li>
<li>Both, left and right, binary trees are also binary search trees</li>
</ul>
<pre class="mermaid">graph TD
    A((60)) --&gt; B((50))
    A((60)) --&gt; C((70))
    B((50)) --&gt; D((30))
    B((50)) --&gt; E((55))
    C((70)) --&gt; F((65))
    C((70)) --&gt; G((80))
    G((80)) --&gt; H((75))
</pre>
<h2 id="searching"><a class="header" href="#searching">Searching</a></h2>
<p>To search an item within a binary search tree we must use recursion.</p>
<p>We begin by examining the root:</p>
<ul>
<li>If the given item equals to the item at the root, we return true</li>
<li>If the given item is less than the item at the root, we recursively search the left
sub-tree in the same manner</li>
<li>If the given item is greater than the item at the root, we recursively search the right
sub-tree in the same manner</li>
</ul>
<h2 id="algorithm-6"><a class="header" href="#algorithm-6">Algorithm</a></h2>
<pre><code>ALGORITHM Search(K, root)
if root != null
    if root.item = K
        return true
    else
        if root.item &lt; K
            return Search(K, root.rchild)
        else
            return Search(K, root.lchild)
else
    return false
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="binary-search-tree-insert"><a class="header" href="#binary-search-tree-insert">Binary Search Tree: Insert</a></h1>
<h2 id="inserting"><a class="header" href="#inserting">Inserting</a></h2>
<p>To insert an item within a binary search tree we must first recursively search
for the correct place to insert, and once found, add it below that item.</p>
<p>For example, given the current tree and the value 45 to insert</p>
<pre class="mermaid">graph TD
    A((60)) --&gt; B((50))
    A((60)) --&gt; C((70))
    B((50)) --&gt; D((30))
    B((50)) --&gt; E((55))
    C((70)) --&gt; F((65))
    C((70)) --&gt; G((80))
    G((80)) --&gt; H((75))
</pre>
<p>After our insertion, our tree would look as follows,</p>
<pre class="mermaid">graph TD
    A((60)) --&gt; B((50))
    A((60)) --&gt; C((70))
    B((50)) --&gt; D((30))
    D((30)) --&gt; J((45))
    B((50)) --&gt; E((55))
    C((70)) --&gt; F((65))
    C((70)) --&gt; G((80))
    G((80)) --&gt; H((75))
</pre>
<h2 id="algorithm-7"><a class="header" href="#algorithm-7">Algorithm</a></h2>
<pre><code>ALGORITHM Insert(K, root)
if root = null
    ptr &lt;- new BTNode
    ptr.item &lt;- K
    root &lt;- ptr
else
    if root.item &gt; K
        if root.lchild = null
            ptr &lt;- new BTNode
            ptr.item &lt;- K
            root.lchild &lt;- ptr
        else
            Insert(K, root.lchild)
    else
        if root.rchild = null
            ptr &lt;- new BTNode
            ptr.item &lt;- K
            root.rchild &lt;- ptr
        else
            Insert(K, root.rchild)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="binary-search-tree-delete"><a class="header" href="#binary-search-tree-delete">Binary Search Tree: Delete</a></h1>
<h2 id="deleting"><a class="header" href="#deleting">Deleting</a></h2>
<p>When deleting a node from a binary tree, three cases need to be considered:</p>
<ol>
<li>The node to be deleted is a leaf</li>
<li>The node to be deleted has only one child</li>
<li>The node to be deleted has two children</li>
</ol>
<h3 id="the-node-is-a-leaf"><a class="header" href="#the-node-is-a-leaf">The node is a leaf</a></h3>
<p>If the node to be deleted is a leaf, all we need to do is simply update its parents
pointer to null.</p>
<h3 id="the-node-has-one-child"><a class="header" href="#the-node-has-one-child">The node has one child</a></h3>
<p>If the node to be deleted has only one child, all we need to do is update its parents
pointer to point to the child.</p>
<h3 id="the-node-has-two-children"><a class="header" href="#the-node-has-two-children">The node has two children</a></h3>
<p>If the node to be deleted has two children, we must transform the problem as such
to match one of the previous two cases.</p>
<ol>
<li>Find the right-most node in the left sub-tree pointer</li>
<li>Copy the item of the right-most node to the pointer</li>
<li>Delete the right-most node</li>
</ol>
<h2 id="algorithm-8"><a class="header" href="#algorithm-8">Algorithm</a></h2>
<pre><code>ALGORITHM Delete(K, root)
ptr &lt;- root
parent &lt;- null

while ptr != null and ptr.item != K do
    parent &lt;- ptr
    
    if ptr.item &lt; K
        ptr &lt;- ptr.lchild
    else
        ptr &lt;- ptr.rchild

if ptr != null
    if ptr.lchild != null and ptr.rchild != null
        if ptr.lchild.rchild = null
            ptr.item &lt;- ptr.lchild.item
            ptr.lchild &lt;- ptr.lchild.lchild
        else
            p &lt;- ptr.lchild
            pp &lt;- ptr

            while p.rchild != null do
                pp &lt;- p
                p &lt;- p.rchild

            ptr.item &lt;- p.item
            pp.rchild &lt;- p.lchild
    else
        if ptr.lchild != null
            c &lt;- ptr.lchild
        else
            c &lt;- ptr.rchild

        if ptr = root
            root &lt;- c
        else
            if ptr = parent.lchild
                parent.lchild &lt;- c
            else
                parent.rchild &lt;- c
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="module-references-4"><a class="header" href="#module-references-4">Module References</a></h2>
<p>QUT lectures &amp; slides</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="disclaimer-6"><a class="header" href="#disclaimer-6">Disclaimer</a></h2>
<p>All references used within this module can be found within <a href=".week_6/../week_6/module-references.html">References</a>.</p>
<p>The quizzes used within this module are taken directly from the QUT slides, I do not claim 
them as my own work unless directly specified under the quiz.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="learning-activities-5"><a class="header" href="#learning-activities-5">Learning activities</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-5"><a class="header" href="#introduction-5">Introduction</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="merge-sort"><a class="header" href="#merge-sort">Merge Sort</a></h1>
<p>Merge sort is a stable divide-and-conquer algorithm. This means it works by recursively 
breaking breaking down the problem into two smaller sub-problems until one of these
becomes simple enough to be solved. The solution of all sub-problems then combine
to provide the solution to the original problem.</p>
<p>Merge sort consists of two main processes:</p>
<ol>
<li>Recursively breakdown an (sub)array into two smaller sub-arrays</li>
<li>Combine two sorted sub-arrays to form one sorted (sub)array</li>
</ol>
<pre><code>ALGORITHM Merge(A[i..j], m)
// Merges two sorted sub-arrays A[i..m] and A[m+1..j] into a single sorted sub-array
// A[i..j], via a temporary array T[i..j]

p &lt;- i
q &lt;- m + 1
r &lt;- i

while p &lt;= m and q &lt;= j do
    if A[p] &lt;= A[q] then
        T[r] &lt;- A[p]
        p &lt;- p + 1
    else
        T[r] &lt;- A[q]
        q &lt;- q + 1

    r &lt;- r + 1

if p &lt;= m then
    T[r..j] &lt;- A[p..m]

if q &lt;= j then
    T[r..j] &lt;- A[q..j]

A[i..j] &lt;- T[i..j]
</code></pre>
<pre><code>ALGORITHM MergeSort(A[i..j])
// Sorts sub-array A into non-decreasing order from position i to position j inclusively

if i &lt; j then
    m &lt;- floor((i + j) / 2)
    MergeSort(A[i..m])
    MergeSort(A[m + 1..j])
    Merge(A[i..j], m)
</code></pre>
<h2 id="efficiency-5"><a class="header" href="#efficiency-5">Efficiency</a></h2>
<p>In a worst case scenario, merge sort will take</p>
<p>\[
c_{worst}(n) \in O(n \log n)
\]</p>
<p>where \(n\) represents the length of the array</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-sort"><a class="header" href="#quick-sort">Quick Sort</a></h1>
<p>Quick sort is a non-stable divide-and-conquer algorithm based on two procedures:</p>
<ol>
<li>Partition</li>
<li>Quicksort</li>
</ol>
<pre><code>ALGORITHM Partition(A[l..r])
// Partitions a sub-array by Hoares algorithm using the first element as a pivot
// Input: Sub-array of array A[0..n-1], defined by its left and right indices
//        l and r (l &lt; r)
// Output: Partition of A[l..r], with the split position returned

p &lt;- A[l]
i &lt;- l
j &lt;- r + 1

repeat
    repeat i &lt;- i + 1 until A[i] &gt;= p
    repeat j &lt;- j - 1 until A[j] &lt;= p
    swap(A[i], A[j])
until i &gt;= j

swap(A[i], A[j])
swap(A[l], A[j])

return j
</code></pre>
<pre><code>ALGORITHM Quicksort(A[l..r])
// Sorts a sub-array by quicksort
// Input: Sub-array of array A[0..n-1], defined by its left and right indices
//        l and r (l &lt; r)
// Output: Sub-array A[l..r] sorted in non-decending order

if l &lt; r then
    s &lt;- Partition(A[l..r])
    Quicksort(A[l..s - 1])
    Quicksort(A[s + 1..rl..s])
</code></pre>
<h2 id="efficiency-6"><a class="header" href="#efficiency-6">Efficiency</a></h2>
<p>In a worst case scenario, quick sort will take</p>
<p>\[
c_{worst}(n) \in O(n^2)
\]</p>
<p>Saying that, quick sort has an average case of</p>
<p>\[
c_{avg}(n) \in O(n \log n)
\]</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="heap-sort--complete-binary-trees"><a class="header" href="#heap-sort--complete-binary-trees">Heap Sort &amp; Complete Binary Trees</a></h1>
<h2 id="heap-sort"><a class="header" href="#heap-sort">Heap Sort</a></h2>
<p>Heap sort is a non-stable transform-and-conquer algorithm generally split into two stages:</p>
<ol>
<li>Transformation</li>
<li>Conquer</li>
</ol>
<pre><code>ALGORITHM Heapsort(A[0..n-1])
// Sorts array A into non-decreasing order

HeapBottomUp procedure
for v &lt;- 0 to n-2 do
    Use MaximumKeyDeletion process to delete the root of the heap
</code></pre>
<p>Heapsort has a worst-case time efficiency of:</p>
<p>\[
C_{worst}(n) \in O(n \log n)
\]</p>
<h2 id="complete-binary-tree"><a class="header" href="#complete-binary-tree">Complete Binary Tree</a></h2>
<p>A complete binary tree of height \(h\), is a binary tree that is full down to
level \(h-1\), with level \(h\) filled in from left-to-right.</p>
<p>All nodes at level \(h-2\) and above each have two children. When a node at level
\(h-1\) has children, then all nodes to its left, at the same level, must have
two children each.</p>
<p>When a node at level \(h-1\) has one child, it must be a left child.</p>
<p>For example, this is a complete binary tree:</p>
<pre class="mermaid">graph TD
    A((A)) --&gt; B((B))
    A((A)) --&gt; C((C))
    B((B)) --&gt; D((D))
    B((B)) --&gt; E((E))
    C((C)) --&gt; F((F))
    C((C)) --&gt; G((G))
</pre>
<p>A complete binary tree can be implemented in an array:</p>
<ul>
<li>The root is stored at index 0</li>
<li>If a node is stored at index \(i\) in the array:
<ul>
<li>The left child of the node is stored at index \(2*i+1\), if it exists</li>
<li>The right child of the node is stored at index \(2*i+2\), if it exists</li>
<li>The parent of the node is stored at index \((i-l)/2\), if it is not the root</li>
</ul>
</li>
</ul>
<p>For example, this complete binary tree can be represented as such <code>[6, 3, 5, 9, 2, 10]</code></p>
<pre class="mermaid">graph TD
    A((6)) --&gt; B((3))
    A((6)) --&gt; C((5))
    B((3)) --&gt; D((9))
    B((3)) --&gt; E((2))
    C((5)) --&gt; F((10))
</pre>
<p><em>* Note: Imagine the connection from node <code>5 -&gt; 10</code> is directed left</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="heaps-and-heap-bottom-up"><a class="header" href="#heaps-and-heap-bottom-up">Heaps and Heap Bottom Up</a></h1>
<h2 id="heaps"><a class="header" href="#heaps">Heaps</a></h2>
<p>A heap is a complete binary tree that is either empty or whose root contains
a search key that is greater than or equals to the search key in each of its
children and has heaps as its sub-trees.</p>
<p>This type of heap is also know as a maximum heap.</p>
<pre class="mermaid">graph TD
    A((10)) --&gt; B((9))
    A((10)) --&gt; C((6))
    B((9)) --&gt; D((3))
    B((9)) --&gt; E((2))
    C((6)) --&gt; F((5))
    C((6)) --&gt; G((4))
</pre>
<h2 id="heap-bottom-up"><a class="header" href="#heap-bottom-up">Heap Bottom Up</a></h2>
<p>The heap bottom up algorithm converts a binary tree into a heap.</p>
<pre><code>ALGORITHM HeapBottomUp(H[1..n])
// Constructs a heap from elements of a given array via the bottom-up algorithm
// Input: An array H[1..n] or orderable elements
// Output: A heap H[1..n]

for i &lt;- floor(n/2) downto 1 do
    k &lt;- i
    v &lt;- H[k]
    heap &lt;- false
    
    while not heap and 2 * k &lt;= n do
        j &lt;- 2 * k

        if j &lt; n then
            if H[j] &lt; H[j + 1] then
                j &lt;- j + 1

            if v &gt;= H[j] then
                heap &lt;- true
            else
                H[k] &lt;- H[j]
                k &lt;- j
    H[k] &lt;- v
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="maximum-key-deletion"><a class="header" href="#maximum-key-deletion">Maximum Key Deletion</a></h1>
<p>To delete the maximum key from the heap we must:</p>
<ol>
<li>Exchange the roots new key with the last key \(K\) of the heap.</li>
<li>Decrease the heaps size by 1</li>
<li>&quot;Heapify&quot; the complete binary tree</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="module-references-5"><a class="header" href="#module-references-5">Module References</a></h2>
<p>QUT lectures &amp; slides</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="disclaimer-7"><a class="header" href="#disclaimer-7">Disclaimer</a></h2>
<p>All references used within this module can be found within <a href=".week_7/../week_6/module-references.html">References</a>.</p>
<p>The quizzes used within this module are taken directly from the QUT slides, I do not claim 
them as my own work unless directly specified under the quiz.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="learning-activities-6"><a class="header" href="#learning-activities-6">Learning activities</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trees"><a class="header" href="#trees">Trees</a></h1>
<p>A tree \(T\), is a non-linear data structure made up of one or more nodes such that
\(T\) is partitioned into disjointed subsets. Each tree has a single node called
the root \(r\) where each set branching off the root is a subtree. Trees are 
often used when representing a hierarchy of things, for example, filesystems, 
comments/replies, and family trees.</p>
<p>Here are some other important terms:</p>
<ul>
<li>Parent of node \(n\): The node directly above \(n\)</li>
<li>Child(ren) of node \(n\): The node(s) directly below \(n\)</li>
<li>Root: The only node without a parent</li>
<li>Leaf: A node without any children</li>
<li>Siblings: Nodes that share a common parent node</li>
<li>Subtree: Any node in a tree together with all its decendants</li>
<li>Height: The number of nodes on the longest path from the root to the leaf</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tree-implementation"><a class="header" href="#tree-implementation">Tree Implementation</a></h1>
<p>When implementing a tree we first need to define what a node is. A node has:</p>
<ul>
<li>A value</li>
<li>A pointer to the head of its child linked list</li>
<li>A pointer to the next child
For example, the following tree would be represented as such:</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="breadth-first-traversal"><a class="header" href="#breadth-first-traversal">Breadth First Traversal</a></h1>
<p>In a breadth-first traversal algorithm, we visit all nodes in a tree in order
of their depth. It will first visit all nodes, left to right, at depth zero, then visit all 
nodes at depth one, and so on until all nodes are traversed.</p>
<h2 id="pseudocode-3"><a class="header" href="#pseudocode-3">Pseudocode</a></h2>
<pre><code>ALGORITHM BreadthFirstTraversal(root)
q &lt;- empty queue
q.enqueue(root)

while q != empty queue do
    r &lt;- q.dequeue()
    visit r
    r &lt;- r.firstchild

    while r != null do
        q.enqueue(r)
        r &lt;- r.firstsibling
</code></pre>
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<pre class="mermaid">flowchart TD
    A((A)) --&gt; B((B))
    A((A)) --&gt; C((C))
    A((A)) --&gt; E((E))
    B((B)) --&gt; F((F))
    B((B)) --&gt; G((G))
    B((B)) --&gt; H((H))
    E((E)) --&gt; I((I))
    E((E)) --&gt; J((J))
</pre>
<p>Queue q:</p>
<ul>
<li>Initially - [ A ]</li>
<li>After visiting A - [ B, C, E ]</li>
<li>After visiting B - [ C, E, F, G, H ]</li>
<li>After visiting C - [ E, F, G, H ]</li>
<li>After visiting E - [ F, G, H, I, J ]</li>
<li>After visiting F - [ G, H, I, J ]</li>
<li>After visiting G - [ H, I, J ]</li>
<li>After visiting H - [ I, J ]</li>
<li>After visiting I - [ J ]</li>
<li>After visiting J - [ ]</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="depth-first-traversal"><a class="header" href="#depth-first-traversal">Depth First Traversal</a></h1>
<p>In a depth-first traversal algorithm, we start at the root and traverse each sub-tree
in depth-first order from left to right.</p>
<h2 id="pseudocode-4"><a class="header" href="#pseudocode-4">Pseudocode</a></h2>
<pre><code>ALGORITHM DepthFirstTraversal(root)
s &lt;- empty stack
s.push(root)

while s != empty stack do
    r &lt;- s.pop()

    repeat
        visit r
        
        if r.firstsibling != null then
            s.push(r.firstsibling)

        r &lt;- r.firstchild
    until r = null
            
</code></pre>
<h2 id="example-2"><a class="header" href="#example-2">Example</a></h2>
<pre class="mermaid">flowchart TD
    A((A)) --&gt; B((B))
    A((A)) --&gt; C((C))
    A((A)) --&gt; E((E))
    B((B)) --&gt; F((F))
    B((B)) --&gt; G((G))
    B((B)) --&gt; H((H))
    E((E)) --&gt; I((I))
    E((E)) --&gt; J((J))
</pre>
<p>Stack s:</p>
<ul>
<li>Initially - [ A ]</li>
<li>After visiting A - [ ]</li>
<li>After visiting B - [ C ]</li>
<li>After visiting F - [ C, G ]</li>
<li>After visiting G - [ C, H ]</li>
<li>After visiting H - [ C ]</li>
<li>After visiting C - [ E ]</li>
<li>After visiting E - [ ]</li>
<li>After visiting I - [ J ]</li>
<li>After visiting J - [ ]</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="module-references-6"><a class="header" href="#module-references-6">Module References</a></h2>
<p>QUT lectures &amp; slides</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="disclaimer-8"><a class="header" href="#disclaimer-8">Disclaimer</a></h2>
<p>All references used within this module can be found within <a href=".week_8/../week_6/module-references.html">References</a>.</p>
<p>The quizzes used within this module are taken directly from the QUT slides, I do not claim 
them as my own work unless directly specified under the quiz.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="learning-activities-7"><a class="header" href="#learning-activities-7">Learning activities</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-6"><a class="header" href="#introduction-6">Introduction</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graphs"><a class="header" href="#graphs">Graphs</a></h1>
<h2 id="graph"><a class="header" href="#graph">Graph</a></h2>
<p>A graph \(G\) consists of two sets:</p>
<ol>
<li>A set \(V\) of vertices</li>
<li>A set \(E\) of edges that connect the vertices</li>
</ol>
<p>For example:</p>
<ul>
<li>\(G = ( V, E )\)</li>
<li>\(V = \{A, B, C, D, E\}\)</li>
<li>\(E = \{(A, B), (A, C), (A, D), (A, E), (B, C), (C, D), (D, E)\}\)</li>
</ul>
<p><img src="week_8/../assets/graph-example.png" alt="Graph example" /></p>
<h2 id="terminology"><a class="header" href="#terminology">Terminology</a></h2>
<h3 id="undirected-graph"><a class="header" href="#undirected-graph">Undirected Graph</a></h3>
<p>In an undirected graph, edges do not indicate any direction.</p>
<p><img src="week_8/../assets/graph-example.png" alt="Graph example" /></p>
<h3 id="directed-graph"><a class="header" href="#directed-graph">Directed Graph</a></h3>
<p>In an directed graph, edges indicate a direction of flow.</p>
<p><img src="week_8/../assets/directed-graph-example.png" alt="Directed Graph example" /></p>
<h3 id="weighted-graph"><a class="header" href="#weighted-graph">Weighted Graph</a></h3>
<p>In an weighted graph, edges have a weight/value associated with them.</p>
<p><img src="week_8/../assets/weighted-graph-example.png" alt="Weighted Graph example" /></p>
<h3 id="path"><a class="header" href="#path">Path</a></h3>
<p>A path between two vertices is the sequence of consecutive edges beginning at one
vertex and ending at another.</p>
<p>For example, e1 - e3 - e4 is a path between A and D:</p>
<p><img src="week_8/../assets/labeled-graph-example.png" alt="Path example" /></p>
<h3 id="cycle"><a class="header" href="#cycle">Cycle</a></h3>
<p>A cycle is a path that begins and ends at the same vertex.</p>
<p>For example, e1 - e3 - e6 is a cycle beginning and ending at A:</p>
<p><img src="week_8/../assets/labeled-graph-example.png" alt="Cycle example" /></p>
<h3 id="connected-graph"><a class="header" href="#connected-graph">Connected Graph</a></h3>
<p>A graph is considered to be connected if there exists a path between each pair
of distinct vertices.</p>
<p><img src="week_8/../assets/graph-example.png" alt="Connected Graph example" /><br />
<strong>Figure: Connected Graph</strong></p>
<p><img src="week_8/../assets/disconnected-graph-example.png" alt="Disconnected Graph example" /><br />
<strong>Figure: Disconnected Graph</strong></p>
<h3 id="subgraph"><a class="header" href="#subgraph">Subgraph</a></h3>
<p>A subgraph is a graph within a greater graph consisting of a subset of the greater 
graphs vertices and a subset of the greater graphs edges.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adjacency-matrix"><a class="header" href="#adjacency-matrix">Adjacency Matrix</a></h1>
<h2 id="adjacency-matrix-1"><a class="header" href="#adjacency-matrix-1">Adjacency Matrix</a></h2>
<h3 id="unweighted-undirected-graph"><a class="header" href="#unweighted-undirected-graph">Unweighted Undirected Graph</a></h3>
<p>An adjacency matrix for an unweighted undirected graph of \(N\) vertices is 
an \(N \cdot N \) array \(A\) such that \(A[i][j]\) is 1 if there is an edge
between vertex \(i\) and \(j\), and 0 otherwise.</p>
<p>For example, some graph \(G\):</p>
<ul>
<li>\(V = \{A, B, C, D, E\}\)</li>
<li>\(E = \{(A, B), (A, C), (A, D), (A, E), (B, C), (C, D), (D, E)\}\)</li>
</ul>
<p>would be represented as an adjacency matrix like so:</p>
<pre><code>  A B C D E
A 0 1 1 1 1
B 1 0 1 0 0
C 1 1 0 1 0
D 1 0 1 0 1
E 1 0 0 1 0
</code></pre>
<h3 id="weighted-undirected-graph"><a class="header" href="#weighted-undirected-graph">Weighted Undirected Graph</a></h3>
<p>An adjacency matrix for an weighted undirected graph of \(N\) vertices is 
an \(N \cdot N \) array \(A\) such that \(A[i][j]\) is the weight of the edge
between vertex \(i\) and \(j\), and \(\infty\) otherwise.</p>
<h3 id="unweighted-directed-graph"><a class="header" href="#unweighted-directed-graph">Unweighted Directed Graph</a></h3>
<p>An adjacency matrix for an unweighted directed graph of \(N\) vertices is 
an \(N \cdot N \) array \(A\) such that \(A[i][j]\) is 1 if there is a
directed edge between vertex \(i\) and \(j\), and \(\infty\) otherwise.</p>
<h3 id="weighted-directed-graph"><a class="header" href="#weighted-directed-graph">Weighted Directed Graph</a></h3>
<p>An adjacency matrix for an unweighted directed graph of \(N\) vertices is 
an \(N \cdot N \) array \(A\) such that \(A[i][j]\) is the weight of the
directed edge between vertex \(i\) and \(j\), and \(\infty\) otherwise.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adjacency-list"><a class="header" href="#adjacency-list">Adjacency List</a></h1>
<h3 id="unweighted-undirected-graph-1"><a class="header" href="#unweighted-undirected-graph-1">Unweighted Undirected Graph</a></h3>
<p>An adjacency list for an unweighted undirected graph of \(N\) vertices 
consists of \(N\) linked lists, each of which represents a vertex. The nodes
in the linked list represent those vertices that are adjacent to the vertex.</p>
<p>For example, some graph \(G\):</p>
<ul>
<li>\(V = \{A, B, C, D, E\}\)</li>
<li>\(E = \{(A, B), (A, C), (A, D), (A, E), (B, C), (C, D), (D, E)\}\)</li>
</ul>
<p>would be represented as an adjacency list like so:</p>
<pre><code>A -&gt; B: -&gt; C: -&gt; D: -&gt; E:
B -&gt; A: -&gt; C:
C -&gt; A: -&gt; B: -&gt; D:
D -&gt; A: -&gt; C: -&gt; E:
E -&gt; A: -&gt; D:
</code></pre>
<h3 id="weighted-undirected-graph-1"><a class="header" href="#weighted-undirected-graph-1">Weighted Undirected Graph</a></h3>
<p>An adjacency list for an weighted undirected graph of \(N\) vertices 
consists of \(N\) linked lists, each of which represents a vertex. The nodes
in the linked list represent those vertices that are adjacent to the vertex.
Along with the nodes, an additional attribute is added representing the weight.</p>
<p>For example:</p>
<pre><code>A -&gt; B:3 -&gt; C:6 -&gt; D:7 -&gt; E:4
B -&gt; A:3 -&gt; C:2
C -&gt; A:6 -&gt; B:2 -&gt; D:1
D -&gt; A:7 -&gt; C:1 -&gt; E:2
E -&gt; A:4 -&gt; D:2
</code></pre>
<h3 id="unweighted-directed-graph-1"><a class="header" href="#unweighted-directed-graph-1">Unweighted Directed Graph</a></h3>
<p>An adjacency list for an unweighted directed graph of \(N\) vertices 
consists of \(N\) linked lists, each of which represents a vertex. The nodes
in the linked list represent those vertices that there exists a directed edge 
from the vertex.</p>
<h3 id="weighted-directed-graph-1"><a class="header" href="#weighted-directed-graph-1">Weighted Directed Graph</a></h3>
<p>An adjacency list for an weighted directed graph of \(N\) vertices 
consists of \(N\) linked lists, each of which represents a vertex. The nodes
in the linked list represent those vertices that there exists a directed edge 
from the vertex. Along with the nodes, an additional attribute is added 
representing the weight.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graph-traversal"><a class="header" href="#graph-traversal">Graph Traversal</a></h1>
<h2 id="graph-traversal-1"><a class="header" href="#graph-traversal-1">Graph Traversal</a></h2>
<p>In a graph traversal algorithm, all vertices within a graph are visited.
There are two graph traversal algorithms:</p>
<ol>
<li>Depth-first search traversal</li>
<li>Breadth-first search traversal</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="depth-first-search"><a class="header" href="#depth-first-search">Depth-first Search</a></h1>
<h2 id="depth-first-search-1"><a class="header" href="#depth-first-search-1">Depth-first Search</a></h2>
<p>Given a vertex \(v\), the depth-first search traversal proceeds along
a path from \(v\) branching left at each vertex until it can no longer 
traverse deeper, i.e. the last vertex. Once it can no longer proceed, it 
backtracks and proceeds again.</p>
<pre><code>ALGORITHM DFS(G)
// Implements a depth-first search traversal of a given graph
// Input:
//     Graph G = &lt;V, E&gt;
// Output
//     Graph G with its vertices marked with consecutive integers
//     in the order they were first encountered

mark each vertex in V with 0 as a mark of being &quot;unvisited&quot;
count &lt;- 0
for each vertex v in V do
    if v is marked with 0
        dfs(v)
</code></pre>
<pre><code>PROCEDURE dfs(v)
count &lt;- count + 1
mark v with count

for each vertex w in V adjacent to v do
    if w is marked with 0 then
        dfs(w)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="breadth-first-search"><a class="header" href="#breadth-first-search">Breadth-first Search</a></h1>
<h2 id="breadth-first-search-1"><a class="header" href="#breadth-first-search-1">Breadth-first Search</a></h2>
<p>Given a vertex \(v\), after visiting it, visit all the unvisited vertices
that are adjacent to \(v\). Then, visit all the unvisited vertices that are
two edges apart from \(v\), and so on until all vertices have been visited.</p>
<pre><code>ALGORITHM BFS(G)
// Implements a breadth-first search traversal of a given graph
// Input:
//     Graph G = &lt;V, E&gt;
// Output
//     Graph G with its vertices marked with consecutive integers
//     in the order they were visited

mark each vertex in V with 0 as a mark of being &quot;unvisited&quot;
count &lt;- 0
for each vertex v in V do
    if v is marked with 0
        bfs(v)
</code></pre>
<pre><code>PROCEDURE bfs(v)
count &lt;- count + 1
mark v with count
initialise a queue with v

while the queue is not empty do
    for each vertex w in V adjacent to the front vertex do
        if w is marked with 0 then
            count &lt;- count + 1
            mark w with count
            add w to the queue

    remove the front vertex from the queue
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="topological-sort"><a class="header" href="#topological-sort">Topological Sort</a></h1>
<h2 id="topological-sort-1"><a class="header" href="#topological-sort-1">Topological Sort</a></h2>
<p>A topological sort algorithm is used DAGs, directed acyclic graphs.</p>
<p>A DAG has a natural order, i.e. you must visit node A before node B.</p>
<p>Topological sorting is to find the order of vertices in a DAG such that each
vertex comes before all vertices which it has an edge to.</p>
<pre><code>ALGORITHM TopologicalSort(G)
// Input:
//     DAG G = &lt;V, E&gt;
// Output
//     A sequence of all the vertices of G such that each vertex
//     comes before all vertices to which it has an edge

G'(V', E') &lt;- G(V, E)

while V' != an empty set do
    find a vertex v thats in V' such that in-degree(v) = 0
    output v
    remove v and all the edges adjacent to v

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spanning-tree--minimum-spanning-tree"><a class="header" href="#spanning-tree--minimum-spanning-tree">Spanning Tree &amp; Minimum Spanning Tree</a></h1>
<h2 id="spanning-tree"><a class="header" href="#spanning-tree">Spanning Tree</a></h2>
<p>A spanning tree of a connected undirected graph \(G\) is a connected subgraph
of \(G\) such that all of \(G\)s vertices and is \(n-1\) of \(G\)s edges,
where \(n\) is the number of vertices in \(G\).</p>
<p>It's possible for a graph to have many different spanning trees.</p>
<h2 id="minimum-spanning-tree"><a class="header" href="#minimum-spanning-tree">Minimum Spanning Tree</a></h2>
<p>A minimum spanning tree of a connected undirected graph is a spanning tree
which has the minimal sum of edge weights.</p>
<p>There are two popular minimum spanning tree algorithms:</p>
<ol>
<li>Kruskal's algorithm</li>
<li>Prim's algorithm</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kruskals-algorithm"><a class="header" href="#kruskals-algorithm">Kruskal's Algorithm</a></h1>
<h2 id="kruskals-algorithm-1"><a class="header" href="#kruskals-algorithm-1">Kruskal's Algorithm</a></h2>
<p>Kruskal's algorithm works by first sorting the edges of the graph in ascending
order and then tries to add edges one by one to an initially empty tree. If, 
when the item is added, a cycle is not formed, then the edge is included otherwise
not. This process is repeated until \(n - 1\) edges have been added to the tree,
where \(n\) is the number of the vertices in the graph.</p>
<pre><code>ALGORITHM Kruskal(G)
// Kruskal's algorithm for constructing a minimum spanning tree
// Input:
//     A weighted connected graph G = &lt;V, E&gt;
// Output:
//     E_{T}, the set of edges composing a minimum spanning tree of G

sort E in non-decreasing order of the edge weights w(e_{i_{1}}) &lt;= ... &lt;= w(e_{i_{|E|}})
E_{T} &lt;- empty set
e_counter &lt;- 0
k &lt;- 0

while e_counter &lt; |V| - 1 do
    k &lt;- k + 1
    if E_{T} union {e_{i_{k}}} is acyclic
        E_{T} &lt;- E_{T} union {e_{i_{k}}}
        e_counter &lt;- e_counter + 1

return E_{T}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="primss-algorithm"><a class="header" href="#primss-algorithm">Prims's Algorithm</a></h1>
<h2 id="primss-algorithm-1"><a class="header" href="#primss-algorithm-1">Prims's Algorithm</a></h2>
<p>Prim's algorithm begins with any vertex. Initially, the minimum spanning tree
contains only the starting vertex.</p>
<p>At each stage, the algorithm selects a least-cost edge from among those that
begin with a vertex in the tree and end with a vertex not in the tree. The latter
vertex and least-cost edge are then added to the tree.</p>
<p>This process is repeated until all the vertices are added to the tree</p>
<pre><code>ALGORITHM Prim(G)
// Prims's algorithm for constructing a minimum spanning tree
// Input:
//     A weighted connected graph G = &lt;V, E&gt;
// Output:
//     E_{T}, the set of edges composing a minimum spanning tree of G

V_{T} &lt;- {v_{0}}
E_{T} &lt;- an empty set

for i &lt;- 1 to |V| - 1 do
    find the minimum weighted edge e* = (v*, u*) among all the edges in (v, u)
    such that v is in V_{T} and u is in V - V_{T}

    V_{T} &lt;- V_{T} union {u*}
    E_{T} &lt;- E_{T} union {e*}

return E_{T}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="module-references-7"><a class="header" href="#module-references-7">Module References</a></h2>
<p>QUT lectures &amp; slides</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="week-9"><a class="header" href="#week-9">Week 9</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="learning-activities-8"><a class="header" href="#learning-activities-8">Learning activities</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-7"><a class="header" href="#introduction-7">Introduction</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shortest-path-algorithms"><a class="header" href="#shortest-path-algorithms">Shortest Path Algorithms</a></h1>
<h2 id="the-shortest-path-problem"><a class="header" href="#the-shortest-path-problem">The Shortest Path Problem</a></h2>
<p>The shortest path between two given vertices in a weighted graph can be defined
as the path which has the minimal sum of its edges weights.</p>
<p>There are three categories for shortest path algorithms:</p>
<ol>
<li>A* Algorithm: Finding the shortest path/distance between two vertices</li>
<li>Dijkstra's Algorithm: Finding the shortest path/distance between a vertex to all other vertices in 
the graph</li>
<li>Floyd's Algorithm: Finding the shortest path/distance between every pair of vertices in a graph </li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dijkstras-algorithm"><a class="header" href="#dijkstras-algorithm">Dijkstras Algorithm</a></h1>
<h2 id="dijkstras-algorithm-1"><a class="header" href="#dijkstras-algorithm-1">Dijkstras Algorithm</a></h2>
<p>Dijksta's algorithm is an algorithm designed to find the shortest path/distance
between a vertex and all other vertices in a weighted graph.</p>
<p>It works by:</p>
<ol>
<li>Finding the shortest distance from the source vertex to a vertex nearest to it.</li>
<li>Finding the shortest distance from the source vertex to a vertex second nearest 
to it</li>
<li>Repeated steps 1, then 2, until there are no more to traverse</li>
</ol>
<h2 id="algorithm-9"><a class="header" href="#algorithm-9">Algorithm</a></h2>
<pre><code>// Input: 
//     A: the matrix representation of G;
// Output: 
//     W: an array containing the shortest path lengths between vertex u and 
//        all the other vertices in graph G(V, E). Assume that vertices are 
//        represented by their corresponding row/column number
ALGORITHM Dijkstra (G, u)
    S ← {u}
    N ←|V|

    for j = 0 to N-1 do
        W[j] = A[u][j]

    for i = 2 to N do
        find the smallest W[v] such that v is not in S;
        S ← S + {v}

        for all vertices x not in S do
            if W[x] &gt; W[v] + A[v][x]
                W[x] = W[v] + A[v][x]

    return W
</code></pre>
<p>The time efficiency of this version of Dijkstra's algorithm is considered \(O(n^3)\). However, if we implemented
it as a priority queue, the time efficiency would be \(O(n^2)\).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="floyds-algorithm"><a class="header" href="#floyds-algorithm">Floyds Algorithm</a></h1>
<h2 id="floyds-algorithm-1"><a class="header" href="#floyds-algorithm-1">Floyds Algorithm</a></h2>
<p>Floyd's algorithm is an algorithm designed to find the shortest path/distance
from each vertex to all other vertices in a weighted graph.</p>
<p>It works by gradually building up all possible paths/distances from vertex \(i\) to
vertex \(j\) in turn finding the shortest path/distance between the two vertices.</p>
<p>It does this by computing the distance matrix of a weighted graph with \(n\) vertices,
\(D\), through a series of \(n \cdot n\) matrices. \(d_{ij}^{(k)}\) in the \(i^{th}\) row
and the \(j^{th}\) column of matrix \(D^{(k)}\) is equal to the length of the shortest
path among all paths from the \(i^{th}\) vertex to the \(j^{th}\) vertex with each
intermediate vertex, if any, numbered not higher than \(k\).</p>
<p>The recurrence formula is:
\[
d_{ij}^{(k)} = min\{d_{ij}^{(k-1)}, d_{ik}^{(k-1)} + d_{ki}^{(k-1)}\} \text{ for } k \ge 1
\]</p>
<h2 id="algorithm-10"><a class="header" href="#algorithm-10">Algorithm</a></h2>
<pre><code>// Input: 
//     - The weight matrix M of a graph with no negative-length cycles
// Output: 
//     - The distance of the shortest paths lengths
ALGORITHM Floyd(M[1..n, 1..n])
    D ← M
    for k ← 1 to n do
        for i ← 1 to n do
            for j ← 1 to n do
                D[i, j] ← min{D[i, j], D[i, k] + D[k, j]}

    return D
</code></pre>
<p>The time efficiency of Floyd's algorithm is considered \(O(n^3)\).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="references"><a class="header" href="#references">References</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="week-10"><a class="header" href="#week-10">Week 10</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="learning-activities-9"><a class="header" href="#learning-activities-9">Learning activities</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-8"><a class="header" href="#introduction-8">Introduction</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterative-improvement"><a class="header" href="#iterative-improvement">Iterative Improvement</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="maximum-flow-algorithm"><a class="header" href="#maximum-flow-algorithm">Maximum Flow Algorithm</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ford-fulkerson-algorithm"><a class="header" href="#ford-fulkerson-algorithm">Ford-Fulkerson Algorithm</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="efficiency-degradation-of-the-augmenting-path-method"><a class="header" href="#efficiency-degradation-of-the-augmenting-path-method">Efficiency Degradation of the Augmenting Path Method</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shortest-augmenting-path-algorithm"><a class="header" href="#shortest-augmenting-path-algorithm">Shortest Augmenting Path Algorithm</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="maximum-bipartite-matching-algorithm"><a class="header" href="#maximum-bipartite-matching-algorithm">Maximum Bipartite Matching Algorithm</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="references-1"><a class="header" href="#references-1">References</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
